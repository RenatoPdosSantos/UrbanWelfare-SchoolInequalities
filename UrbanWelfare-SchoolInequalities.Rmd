---
title: "School Inequalities and Urban Welfare: Going beyond Socioeconomic Status with Data Science"
author: "Renato P. dos Santos and Isadora L. Lemes"
date: "18 October 2018"
output: word_document
---

```{r Setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract
The changing Brazilian urban reality segregates people in socio-spatial terms and distributes urban public resources unfairly, threatening student's access to the structure of educational opportunities and causing school inequalities. In this paper, 20 factors such as existence of public lighting, open sewage and garbage accumulated around the homes, as well as electricity and water supply, sanitation, and the number of residents per bathroom as predictors of school achievements as measured using their average ENEM (National High School Exam) outcomes are discussed using Data Science methods. Results show that the Urban Housing Conditions have a higher correlation than students' socioeconomic status, relations that are clearly illustrated by means of bivariate choropleth maps across all the 5,564 Brazilian municipalities. This seems to confirm that the uneven distribution of urban conditions reduces educational opportunities and engenders social inequalities that are incompatible with a sustainable society.

##Keywords
schooling inequalities; social inequalities; sustainability; urban inequalities; urban welfare

```{r Environment, echo = FALSE}
# Enviroment values
R.version <- sessionInfo()$R.version$version.string
RStudio.version <- as.character(RStudio.Version()$version[1])
OS.version <- sessionInfo()$running
platform <- sessionInfo()$platform
```

```{r silentLoad, echo = FALSE}
silentLoad <- function(pckg) {
  if (!(pckg %in% available.packages())) {
    return(paste("package",
                 pckg,
                 "not available!"))
  }
  if (!(pckg %in% installed.packages())) {
    suppressMessages(install.packages(pckg))
  }
  suppressMessages(library(pckg,
                           character.only = TRUE))
}
```

```{r Packages, echo = FALSE}
#suppressMessages(library(xlsx)) # XML files manipulation
silentLoad("scales") # Scale functions for visualization
silentLoad("broom") # Convertion of statistical analysis objects into tidy data frames
silentLoad("maptools") # Reading and Handling Spatial Objects
silentLoad("mapproj") # Convertion of latitude/longitude into projected coordinates
silentLoad("rgdal") # Bindings for the Geospatial Data Abstraction Library
silentLoad("ggplot2") # Elegant data visualisations using the grammar of graphics
silentLoad("readr") # Fast and friendly reading of '.csv', '.tsv', and '.fwf' data
silentLoad("plyr") # Tools for Splitting, Applying and Combining Data. Required for XGBoost Method (must be loaded before dplyr)
#silentLoad("gpclib") # General polygon clipping library for R
silentLoad("rgeos") # Interface to Geometry Engine - Open Source (GEOS)
silentLoad("ggsn") # North Symbols and Scale Bars for Maps Created with 'ggplot2' or 'ggmap'
silentLoad("digest") # Create compact hash digests of R objects
silentLoad("psych") # Functions for analyzing data at multiple levels
silentLoad("colorplaner") # A 'ggplot2' extension to create a bivariate choropleth in R with multivariate color scales.
silentLoad("data.table")
silentLoad("Hmisc") # Miscellaneous useful functions for data analysis
silentLoad("knitr") # General-purpose tool for dynamic report generation in R
silentLoad("corrplot") # Graphical display of correlation matrix
silentLoad("extrafont") # Tools to using system TrueType fonts 
windowsFonts(Arial=windowsFont("TT Arial"))
silentLoad("Cairo") # Library for  high-quality output
silentLoad("rmarkdown") # Dynamic documents for R

citations <- function(includeURL = TRUE, includeRStudio = TRUE) {
    if(includeRStudio == TRUE) {
        ref.rstudio <- RStudio.Version()$citation
        if(includeURL == FALSE) {
            ref.rstudio$url = NULL;
        }
        print(ref.rstudio, style = 'text')
        cat('\n')
    }

    cit.list <- c('base', names(sessionInfo()$otherPkgs))
    for(i in 1:length(cit.list)) {
        ref <- citation(cit.list[i])
        if(includeURL == FALSE) {
            ref$url = NULL;
        }
        print(ref, style = 'text')
        cat('\n')
    }
}

# ++++++++++++++++++++++++++++
# flattenCorrMatrix
# Source: http://www.sthda.com/english/wiki/correlationmatrixaquickstartguidetoanalyzeformatandvisualizeacorrelationmatrixusingrsoftware
# ++++++++++++++++++++++++++++
# cormat : matrix of the correlation coefficients
# pmat : matrix of the correlation p-values
flattenCorrMatrix <- function(cormat, pmat, digits = 2) {
    ut <- upper.tri(cormat)
    data.frame(
        row = rownames(cormat)[row(cormat)[ut]],
        column = rownames(cormat)[col(cormat)[ut]],
        cor = formatC((cormat)[ut], format = "f", digits),
        p = formatC((pmat[ut]), format = "E", digits)
    )
}

# Indices standardization. Centers it around its minimum if it is a
# positive index, around its maximum otherwise. Scales to its range in
# any case.
IndicStand <- function(Indic, negative = FALSE) {
        if (negative) {
                center <- max(Indic, na.rm = TRUE)
                scale <-
                        min(Indic, na.rm = TRUE) - max(Indic, na.rm = TRUE)
        } else {
                center <- min(Indic, na.rm = TRUE)
                scale <-
                        max(Indic, na.rm = TRUE) - min(Indic, na.rm = TRUE)
        }
        (Indic - center) / scale
}
```

## Composition of the IBEU index

Five dimensions (D1 - D5), each composed of one to seven indices
D1: Urban Mobility:
1. Home-to-Work Displacement
D2: Urban Environmental Conditions:
2. Arborization around households
3. Open sewage in the vicinity of households
4. Accumulated garbage around households
D3: Urban Housing Conditions:
5. Subnormal clump
6. Household density: number of people in the household per number of dormitories
7. Resident / Bathroom Density 
8. Household wall material
9. Species of households
D4: Attendance of Urban Collective Services:
10. Water supply
11. Sewage treatment
12. Electricity supply
13. Waste collection
D5: Urban Infrastructure:
14. Public lighting
15. Paving
16. Sidewalk
17. Curb / Guide
18. Road gully
19. Wheelchair ramp
20. Street address identification

Polygons of Brazilian States and Municipalities. Retrieved from: http://www.gmapas.com/poligonos-ibge/municipios-do-brasil

```{r Polygons, echo = FALSE}
# Polygons of Brazilian States and Municipalities
municipiosFile <- "data/municipios.kml"
layersList <- ogrListLayers(municipiosFile)
municipios <- readOGR(
    municipiosFile,
    layer = layersList[1],
    stringsAsFactors = FALSE,
    encoding = "UTF-8", 
    use_iconv = TRUE
)
# Transform to a data frame for ggplot2 graphics facility
municipiosDF <- tidy(municipios)

## Order matters for geom_path!
municipiosDF <- municipiosDF[order(municipiosDF$order),]

# Extract list of ID's and municipalities names
IDlist <- data.frame(
        id = sapply(municipios@polygons, function(x) slot(x, 'ID')),
        nome = municipios@data$Name,
        stringsAsFactors = FALSE
)
keepList <- IDlist$id[IDlist$nome != ""]
IDlist <- subset(IDlist, (id %in% keepList))
municipiosDF <- subset(municipiosDF, (id %in% keepList))
```

Table of Codes of Municipalities. Retrieved from: http://concla.ibge.gov.br/classificacoes/por-tema/codigo-de-areas/codigo-de-areas.html

```{r geocodigos}
# Geocodes from IBGE
codigosFile <- "data/municipios-codes.csv"
# Read only relevant variables
codigosDF <- read_csv2(
    codigosFile,
    col_names = TRUE,
    cols_only(UF = col_character(),
              Municipio = col_character(),
              Nome_Municipio = col_character()),
    locale(encoding = "UTF-8")
)
codigosDF$CodMunicipio <- as.numeric(paste0(codigosDF$UF, codigosDF$Municipio))
codigosDF <- subset(codigosDF, !duplicated(codigosDF$CodMunicipio))
codigosDF <- codigosDF[order(codigosDF$CodMunicipio),]
codigosDF <- rename(codigosDF, c("Nome_Municipio" = "nome"))
codigosDF$UF <- NULL
codigosDF$Municipio <- NULL

IDlist$CodMunicipio <- codigosDF$CodMunicipio
```

IDEB 2011 data obtained from http://portal.inep.gov.br/web/portal-ideb/planilhas-para-download

```{r IDEB}
# Estatistics from IDEB 2011
IDEBDF <- as.data.frame(read_csv(
    "data/IDEB2011.csv",
    col_names = TRUE, 
    na = c("-"),
    cols_only(
        Codigo = col_integer(),
        IDEB = col_number()
    )
))
IDEBDF <- rename(IDEBDF, c('Codigo' = 'CodMunicipio'))

# Average over municipality
IDEBDF <- aggregate(IDEB ~ CodMunicipio,
                    data = IDEBDF, 
                    FUN = mean)
```

ENEM data obtained from 
http://portal.inep.gov.br/web/guest/microdados

```{r ENEM, echo = FALSE}
# File layout
CensoFileLayout <- as.data.frame(matrix(
    data = c(
        c("NU_ANO_CENSO", "NULL"),
        c("ID_TURMA", "NULL"),
        c("NO_TURMA", "NULL"),
        c("TX_HR_INICIAL", "NULL"),
        c("TX_MI_INICIAL", "NULL"),
        c("NU_DURACAO_TURMA", "NULL"),
        c("NU_MATRICULAS", "NULL"),
        c("TP_MEDIACAO_DIDATICO_PEDAGO", "NULL"),
        c("IN_ESPECIAL_EXCLUSIVA", "numeric"),
        c("IN_REGULAR", "numeric"),
        c("IN_EJA", "NULL"),
        c("IN_PROFISSIONALIZANTE", "NULL"),
        c("EtapaEnsino", "numeric"),
        c("CO_CURSO_EDUC_PROFISSIONAL", "NULL"),
        c("TP_TIPO_TURMA", "NULL"),
        c("IN_MAIS_EDUCACAO", "NULL"),
        c("NU_DIAS_ATIVIDADE", "NULL"),
        c("IN_DIA_SEMANA_DOMINGO", "NULL"),
        c("IN_DIA_SEMANA_SEGUNDA", "NULL"),
        c("IN_DIA_SEMANA_TERCA", "NULL"),
        c("IN_DIA_SEMANA_QUARTA", "NULL"),
        c("IN_DIA_SEMANA_QUINTA", "NULL"),
        c("IN_DIA_SEMANA_SEXTA", "NULL"),
        c("IN_DIA_SEMANA_SABADO", "NULL"),
        c("CO_TIPO_ATIVIDADE_1", "NULL"),
        c("CO_TIPO_ATIVIDADE_2", "NULL"),
        c("CO_TIPO_ATIVIDADE_3", "NULL"),
        c("CO_TIPO_ATIVIDADE_4", "NULL"),
        c("CO_TIPO_ATIVIDADE_5", "NULL"),
        c("CO_TIPO_ATIVIDADE_6", "NULL"),
        c("IN_BRAILLE", "NULL"),
        c("IN_RECURSOS_BAIXA_VISAO", "NULL"),
        c("IN_PROCESSOS_MENTAIS", "NULL"),
        c("IN_ORIENTACAO_MOBILIDADE", "NULL"),
        c("IN_SINAIS", "NULL"),
        c("IN_COMUNICACAO_ALT_AUMENT", "NULL"),
        c("IN_ENRIQ_CURRICULAR", "NULL"),
        c("IN_SOROBAN", "NULL"),
        c("IN_INFORMATICA_ACESSIVEL", "NULL"),
        c("IN_PORT_ESCRITA", "NULL"),
        c("IN_AUTONOMIA_ESCOLAR", "NULL"),
        c("IN_DISC_QUIMICA", "NULL"),
        c("IN_DISC_FISICA", "NULL"),
        c("IN_DISC_MATEMATICA", "NULL"),
        c("IN_DISC_BIOLOGIA", "NULL"),
        c("IN_DISC_CIENCIAS", "NULL"),
        c("IN_DISC_LINGUA_PORTUGUESA", "NULL"),
        c("IN_DISC_LINGUA_INGLES", "NULL"),
        c("IN_DISC_LINGUA_ESPANHOL", "NULL"),
        c("IN_DISC_LINGUA_FRANCES", "NULL"),
        c("IN_DISC_LINGUA_INDIGENA", "NULL"),
        c("IN_DISC_LINGUA_OUTRA", "NULL"),
        c("IN_DISC_ARTES", "NULL"),
        c("IN_DISC_EDUCACAO_FISICA", "NULL"),
        c("IN_DISC_HISTORIA", "NULL"),
        c("IN_DISC_GEOGRAFIA", "NULL"),
        c("IN_DISC_FILOSOFIA", "NULL"),
        c("IN_DISC_ENSINO_RELIGIOSO", "NULL"),
        c("IN_DISC_ESTUDOS_SOCIAIS", "NULL"),
        c("IN_DISC_SOCIOLOGIA", "NULL"),
        c("IN_DISC_EST_SOCIAIS_SOCIOLOGIA", "NULL"),
        c("IN_DISC_INFORMATICA_COMPUTACAO", "NULL"),
        c("IN_DISC_PROFISSIONALIZANTE", "NULL"),
        c("IN_DISC_ATENDIMENTO_ESPECIAIS", "NULL"),
        c("IN_DISC_DIVER_SOCIO_CULTURAL", "NULL"),
        c("IN_DISC_LIBRAS", "NULL"),
        c("IN_DISC_PEDAGOGICAS", "NULL"),
        c("IN_DISC_OUTRAS", "NULL"),
        c("CodEntidade", "numeric"),
        c("CO_REGIAO", "NULL"),
        c("CO_MESORREGIAO", "NULL"),
        c("CO_MICRORREGIAO", "NULL"),
        c("CO_UF", "NULL"),
        c("CodMunicipio", "numeric"),
        c("CO_DISTRITO", "NULL"),
        c("TP_DEPENDENCIA", "NULL"),
        c("TP_LOCALIZACAO", "NULL"),
        c("TP_CATEGORIA_ESCOLA_PRIVADA", "NULL"),
        c("IN_CONVENIADA_PP", "NULL"),
        c("TP_CONVENIO_PODER_PUBLICO", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_EMP", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_ONG", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIND", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIST_S", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_S_FINS", "NULL"),
        c("TP_REGULAMENTACAO", "NULL"),
        c("TP_LOCALIZACAO_DIFERENCIADA", "NULL"),
        c("IN_EDUCACAO_INDIGENA", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(CensoFileLayout) <- c('Fieldname', 'ColType')

ENEMFileLayout <- as.data.frame(matrix(
    data = c(
        c("CodEntidade", "numeric"),
        c("NomeEntidade", "NULL"),
        c("UF", "NULL"),
        c("Munic", "NULL"),
        c("Admin", "NULL"),
        c("Local", "NULL"),
        c("NumAlunos", "numeric"),
        c("Porte", "NULL"),
        c("PartENEM", "NULL"),
        c("TaxPart", "NULL"),
        c("PartNE", "NULL"),
        c("Perm", "NULL"),
        c("SocioEcon", "character"),
        c("FFormDoc", "NULL"),
        c("FormDoc", "NULL"),
        c("Aprov", "NULL"),
        c("Reprov", "NULL"),
        c("Aband", "NULL"),
        c("Top30", "NULL"),
        c("Media", "numeric"),
        c("Nivel1", "NULL"),
        c("Nivel2", "NULL"),
        c("Nivel3", "NULL"),
        c("Nivel4", "NULL"),
        c("Nivel5", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(ENEMFileLayout) <- c('Fieldname', 'ColType')

readDataFile <-
        function(filename,
                 header,
                 sep,
                 FileLayout,
                 skip,
                 nrows,
                 comment.char
                 ) {
                # Read datafile
                if (!file.exists(paste0("data/", filename)))
                        stop(paste("File", filename, "not found!"))
                readData <- read.table(
                        file = paste0("data/", filename),
                        header = header,
                        sep = sep,
                        colClasses = FileLayout$ColType,
                        skip = skip,
                        nrows = nrows,
                        comment.char = comment.char,
                        stringsAsFactors = FALSE,
                        quote=""
                )
                if (nrow(readData) == 0) {
                        stop(paste("Empty file", filename, "!"))
                } else {
                        print(paste(nrow(readData), "lines read."))
                }
                colnames(readData) <- FileLayout$Fieldname[which(FileLayout$ColType != "NULL")]
                readData
        }

CensoData <- 
        readDataFile( 
                filename = "TURMAS.CSV",
                header = TRUE,
                sep = "|",
                FileLayout = CensoFileLayout,
                skip = 0,
                nrows = 3000000,
                comment.char = ""
        )

CensoData <- subset(CensoData, IN_REGULAR == 1 & IN_ESPECIAL_EXCLUSIVA == 0)
CensoData$IN_ESPECIAL_EXCLUSIVA <- NULL
CensoData$IN_REGULAR <- NULL
EnsMedio <- c(25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 64, 67, 71, 74)
CensoData <- subset(CensoData, EtapaEnsino %in% EnsMedio)
CensoData$EtapaEnsino <- NULL
CensoData <- unique(CensoData)
CensoData <- CensoData[!duplicated(CensoData$CodEntidade), ]

ENEMData <- 
        readDataFile(
                filename = "ENEM2015_CHumanas.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
ENEMData <- rename(ENEMData, c("Media" = "CHumanas"))

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_CNatureza.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- rename(NewENEMData, c('Media' = 'CNatureza'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'CNatureza')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Linguagens.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- rename(NewENEMData, c('Media' = 'Linguagens'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Linguagens')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Redacao.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- rename(NewENEMData, c('Media' = 'Redacao'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Redacao')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Matematica.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- rename(NewENEMData, c('Media' = 'Matematica'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Matematica')], by = 'CodEntidade')

ENEMData <- subset(ENEMData, SocioEcon != "Sem informação") 

ENEMDF <- merge(CensoData, ENEMData, by = 'CodEntidade', all = FALSE)

# Tansformations
ENEMDF$SocioEcon <-
        factor(
                ENEMDF$SocioEcon,
                levels = c(
                        "Muito Baixo",
                        "Baixo",
                        "Médio Baixo",
                        "Médio",
                        "Médio Alto",
                        "Alto",
                        "Muito alto"
                ),
                ordered = TRUE
        )

ENEMDF$CHumanas <- ENEMDF$CHumanas * ENEMDF$NumAlunos
ENEMDF$CNatureza <- ENEMDF$CNatureza * ENEMDF$NumAlunos
ENEMDF$Linguagens <- ENEMDF$Linguagens * ENEMDF$NumAlunos
ENEMDF$Redacao <- ENEMDF$Redacao * ENEMDF$NumAlunos
ENEMDF$Matematica <- ENEMDF$Matematica * ENEMDF$NumAlunos
ENEMDF$SocioEcon <- as.numeric(ENEMDF$SocioEcon) * ENEMDF$NumAlunos

ENEMDF <-
        aggregate(
                cbind(
                        NumAlunos,
                        SocioEcon,
                        CHumanas,
                        CNatureza,
                        Linguagens,
                        Redacao,
                        Matematica
                ) ~ CodMunicipio,
                data = ENEMDF,
                FUN = sum,
                na.action = na.omit
        )

ENEMDF$SocioEcon <- ENEMDF$SocioEcon / ENEMDF$NumAlunos
ENEMDF$CHumanas <- ENEMDF$CHumanas / ENEMDF$NumAlunos
ENEMDF$CNatureza <- ENEMDF$CNatureza / ENEMDF$NumAlunos
ENEMDF$Linguagens <- ENEMDF$Linguagens / ENEMDF$NumAlunos
ENEMDF$Redacao <- ENEMDF$Redacao / ENEMDF$NumAlunos
ENEMDF$Matematica <- ENEMDF$Matematica / ENEMDF$NumAlunos

ENEMDF$NumAlunos <- NULL

ENEMDF$ENEM <- rowMeans(ENEMDF[,c('CHumanas', 'CNatureza', 'Linguagens', 'Redacao', 'Matematica')], na.rm = TRUE)
ENEMDF <- subset(ENEMDF, select = c('CodMunicipio', 'ENEM', 'SocioEcon'))
```

```{r IBEU, echo = FALSE}
# Read only relevant variables
# Ler os data a partir do arquivo .xlsx.

# O indicador de deslocamento casa-trabalho é construído a partir do tempo de deslocamento que as pessoas ocupadas que trabalham fora do domicílio, e retornam diariamente para casa, utilizam no trajeto de ida entre o domicílio de residência e o local de trabalho. É considerado como tempo de deslocamento adequado quando as pessoas gastam até 1 hora por dia no trajeto casa-trabalho. Assim, utiliza-se proporção de pessoas ocupadas que trabalham fora do domicílio e retornam para casa diariamente que gastam até 1 hora no trajeto casa-trabalho.

tempo_deslocDF <- as.data.frame(read_csv(
    "data/01_tempo_deslocamento.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
tempo_deslocDF <-
        rename(tempo_deslocDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'TDeslocamento'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
tempo_deslocDF$TDeslocamento <-
        IndicStand(tempo_deslocDF$TDeslocamento, negative = FALSE)

# However, for this work, we also calculated an average travel time for each municipality.
tempo_desloc2DF <- as.data.frame(read_csv(
    "data/tempo_deslocamento2.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
tempo_desloc2DF <-
        rename(tempo_desloc2DF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'TMDeslocamento'))

# The indicator of forestation around households is obtained from the proportion of people living in households whose environment has forestation.
arborizacaoDF <- as.data.frame(read_csv(
    "data/02_arborizacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
arborizacaoDF <-
        rename(arborizacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Arborizacao'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
arborizacaoDF$Arborizacao <-
        IndicStand(arborizacaoDF$Arborizacao, negative = FALSE)

# The indicator of open sewage in the surroundings of the houses is constructed from the proportion of people living in households that do not have open sewage in their surroundings.
esgoto_abertoDF <- as.data.frame(read_csv(
    "data/03_esgoto_ceu_aberto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
esgoto_abertoDF <-
        rename(esgoto_abertoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EsgCeuAberto'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
esgoto_abertoDF$EsgCeuAberto <-
        IndicStand(esgoto_abertoDF$EsgCeuAberto, negative = FALSE)

# The indicator of accumulated garbage in the surroundings of the households is obtained from the proportion of people living in households that do not have accumulated garbage in their surroundings.
lixo_acumDF <- as.data.frame(read_csv(
    "data/04_lixo_acumulado.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
lixo_acumDF <-
        rename(lixo_acumDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'LixoAcumulado'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
lixo_acumDF$LixoAcumulado <-
        IndicStand(lixo_acumDF$LixoAcumulado, negative = FALSE)

# The subnormal clump indicator corresponds to the proportion of people from the weighting area who do not live in subnormal clumps.
aglom_subnormDF <- as.data.frame(read_csv(
    "data/05_aglomerado_subnormal.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
aglom_subnormDF <-
        rename(aglom_subnormDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AglomSubnormal'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
aglom_subnormDF$AglomSubnormal <-
        IndicStand(aglom_subnormDF$AglomSubnormal, negative = FALSE)

# The household density indicator is constructed from the ratio between the number of people in the household and the number of dormitories. It was considered adequate household density when there were up to 2 people per dormitory. The household density indicator was considered as the proportion of people who are in households whose density is up to 2 people per dormitory. Obs: In this work, instead, the average number of people per dormitory per municipality, calculated by the product of the totals of households by the categories of people per dormitory, '1', '2', '3', '4 ', divided by the total number of households in each municipality..
dens_domicilDF <- as.data.frame(read_csv(
    "data/06_densidade_domiciliar.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_domicilDF <-
        rename(dens_domicilDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'DensDomiciliar'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
dens_domicilDF$DensDomiciliar <-
        IndicStand(dens_domicilDF$DensDomiciliar, negative = FALSE)

# The household density indicator is constructed from the ratio between the number of people in the household and the number of dormitories. It was considered adequate household density when there were up to 2 people per dormitory. The household density indicator was considered as the proportion of people who are in households whose density is up to 2 people per dormitory. Obs: In this work, instead, the average number of people per dormitory per municipality, calculated by the product of the totals of households by the categories of people per dormitory, '1', '2', '3', '4 ', divided by the total number of households in each municipality.
dens_mor_banhDF <- as.data.frame(read_csv(
    "data/07_densidade_morador-banheiro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_mor_banhDF <-
        rename(dens_mor_banhDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'DensMoradBanheiro'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
dens_mor_banhDF$DensMoradBanheiro <-
        IndicStand(dens_mor_banhDF$DensMoradBanheiro, negative = FALSE)

# In the indicator of adequacy of household wall material, it was considered as suitable the domicile whose external walls are of the type of masonry with coating or wood suitable for construction (equipped). In this case, the indicator of dequacy of household wall material corresponds to the proportion of people who are in homes with adequate wall material.
material_paredesDF <- as.data.frame(read_csv(
    "data/08_material_paredes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
material_paredesDF <-
        rename(material_paredesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MaterialParedes'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
material_paredesDF$MaterialParedes <-
        IndicStand(material_paredesDF$MaterialParedes, negative = FALSE)

# In the indicator of type of households, it was considered as adequate the households of the type house, village house, condominium or apartment and inadequate the dwellings of the type rooming house, slum,  tenement-houses, tent, and others (wagons, trailers, grottos, etc.). In this case, the household species indicator corresponds to the proportion of people who live in households of adequate species.
especie_domiciliosDF <- as.data.frame(read_csv(
    "data/09_especie_domicilios.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
especie_domiciliosDF <-
        rename(especie_domiciliosDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EspecDomicilio'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
especie_domiciliosDF$EspecDomicilio <-
        IndicStand(especie_domiciliosDF$EspecDomicilio, negative = FALSE)

# Water service is considered adequate when it is done by general water network. The water supply indicator corresponds to the proportion of people living in homes with adequate water supply.
atendimento_aguaDF <- as.data.frame(read_csv(
    "data/10_atendimento_agua.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_aguaDF <-
        rename(atendimento_aguaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoAgua'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_aguaDF$AtendimentoAgua <-
        IndicStand(atendimento_aguaDF$AtendimentoAgua, negative = FALSE)

# Sewage service is considered adequate when it is done by general sewage network. The indicator of sewage service corresponds to the proportion of people who live in the home with adequate sewage service.
atendimento_esgotoDF <- as.data.frame(read_csv(
    "data/11_atendimento_esgoto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_esgotoDF <-
        rename(atendimento_esgotoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEsgoto'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_esgotoDF$AtendimentoEsgoto <-
        IndicStand(atendimento_esgotoDF$AtendimentoEsgoto, negative = FALSE)

# Energy service is considered adequate when there is electricity from distribution companies or other sources, and being from a distributor company when there is a meter. The indicator of energy attendance corresponds to the proportion of people who live at home with adequate energy attendance.
atendimento_energiaDF <- as.data.frame(read_csv(
    "data/12_atendimento_energia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_energiaDF <-
        rename(atendimento_energiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEnergia'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_energiaDF$AtendimentoEnergia <-
        IndicStand(atendimento_energiaDF$AtendimentoEnergia, negative = FALSE)

# Waste collection is considered adequate when waste is collected directly by cleaning service or when placed in a bucket for cleaning service. The indicator of waste collection corresponds to the proportion of people who live in the household with adequate waste collection..
coleta_lixoDF <- as.data.frame(read_csv(
    "data/13_coleta_lixo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
coleta_lixoDF <-
        rename(coleta_lixoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'ColetaLixo'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
coleta_lixoDF$ColetaLixo <-
        IndicStand(coleta_lixoDF$ColetaLixo, negative = FALSE)

# The public lighting indicator corresponds to the proportion of people living in households whose surroundings have public lighting. 
iluminacao_publicaDF <- as.data.frame(read_csv(
    "data/14_iluminacao_publica.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
iluminacao_publicaDF <-
        rename(iluminacao_publicaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IluminacaoPublica'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
iluminacao_publicaDF$IluminacaoPublica <-
        IndicStand(iluminacao_publicaDF$IluminacaoPublica, negative = FALSE)

# The paving indicator corresponds to the proportion of people living at homes whose street has pavement (asphalt, concrete, stones, etc.).
pavimentacaoDF <- as.data.frame(read_csv(
    "data/15_pavimentacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
pavimentacaoDF <-
        rename(pavimentacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Pavimentacao'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
pavimentacaoDF$Pavimentacao <-
        IndicStand(pavimentacaoDF$Pavimentacao, negative = FALSE)

# The sidewalk indicator corresponds to the proportion of people living at homes whose face to the street is located has a sidewalk.
calcadaDF <- as.data.frame(read_csv(
    "data/16_calcada.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
calcadaDF <-
        rename(calcadaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Calcada'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
calcadaDF$Calcada <- IndicStand(calcadaDF$Calcada, negative = FALSE)

# The curb/guide indicator corresponds to the proportion of people living at homes whose face to the street is located has a curb/guide.
meiofio_guiaDF <- as.data.frame(read_csv(
    "data/17_meio-fio_guia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
meiofio_guiaDF <-
        rename(meiofio_guiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MeiofioGuia'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
meiofio_guiaDF$MeiofioGuia <-
        IndicStand(meiofio_guiaDF$MeiofioGuia, negative = FALSE)

# The indicator of road gully corresponds to the proportion of people living in households whose environment has road gullies. The identification of road gullies in the surroundings of the domiciles corresponds to the confronting face face to the street where the domicile is located.
bueiro_boca_de_loboDF <- as.data.frame(read_csv(
    "data/18_bueiro_boca_de_lobo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
bueiro_boca_de_loboDF <-
        rename(bueiro_boca_de_loboDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'BueiroBocadelobo'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
bueiro_boca_de_loboDF$BueiroBocadelobo <-
        IndicStand(bueiro_boca_de_loboDF$BueiroBocadelobo, negative = FALSE)

# The wheelchair ramp indicator corresponds to the proportion of people living at homes whose face of the street where the home is located has a ramp to give access to people who use wheelchairs.
rampa_cadeirantesDF <- as.data.frame(read_csv(
    "data/19_rampa_cadeirantes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
rampa_cadeirantesDF <-
        rename(rampa_cadeirantesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'RampaCadeirantes'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
rampa_cadeirantesDF$RampaCadeirantes <-
        IndicStand(rampa_cadeirantesDF$RampaCadeirantes, negative = FALSE)

# The address identification indicator corresponds to the proportion of people living at home where the street has identification.
ident_logradouroDF <- as.data.frame(read_csv(
    "data/20_identificacao_logradouro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
ident_logradouroDF <-
        rename(ident_logradouroDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IdentLogradouro'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
ident_logradouroDF$IdentLogradouro <-
        IndicStand(ident_logradouroDF$IdentLogradouro, negative = FALSE)
```

```{r IndicatorsData, echo = FALSE}
# All the indices are merged into one single database
IndicatorsData <- merge(
        IDEBDF,
        ENEMDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        tempo_desloc2DF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        tempo_deslocDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        arborizacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        esgoto_abertoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        lixo_acumDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
# As the 'Aglomerado subnormal' indicator was evaluated on the metropolis only, it has entries 322 only and missing values are missing entries are filled with the median of the set of values
IndicatorsData <- merge(
        IndicatorsData,
        aglom_subnormDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
medianValue <- median(aglom_subnormDF$AglomSubnormal)
IndicatorsData$AglomSubnormal <-
    ifelse(is.na(IndicatorsData$AglomSubnormal),
           medianValue,
           IndicatorsData$AglomSubnormal)
IndicatorsData <- merge(
        IndicatorsData,
        dens_domicilDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        dens_mor_banhDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        material_paredesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        especie_domiciliosDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_aguaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_esgotoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_energiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        coleta_lixoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        iluminacao_publicaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        pavimentacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        calcadaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        meiofio_guiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        bueiro_boca_de_loboDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        rampa_cadeirantesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        ident_logradouroDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
# Duplicate entries are eliminated
IndicatorsData <-
        subset(IndicatorsData, !duplicated(IndicatorsData$CodMunicipio))
```

```{r IndicsComparData, echo = FALSE}
IndicsComparData <- subset(IndicatorsData, select = -CodMunicipio)
psych::describe(IndicsComparData)

IndicsCorrMtx <- rcorr(as.matrix(IndicsComparData))
IndicsComparData <- IndicsComparData[, c(names(IndicsComparData['IDEB']),
                         names(sort(abs(IndicsCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
IndicsCorrMtx <- rcorr(as.matrix(IndicsComparData))
CairoPNG(
        filename = paste0("images/", "IndicCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(IndicsCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black',
        tl.cex = 0.8,
        number.cex = 0.5,
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(IndicsCorrMtx$r[1, -1]),
        r = formatC(IndicsCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(IndicsCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)

write.xlsx(
    data.frame(
        var = names(IndicsCorrMtx$r[1, -1]),
        r = formatC(IndicsCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(IndicsCorrMtx$P[1, -1], format = "E", 2)
    ),
    file = "data/IndicsCorrMtx.xls",
    row.names = FALSE,
    col.names = TRUE
)
```

```{r alpha, echo = FALSE}
psych::alpha(
    IndicsComparData[, -1],
    keys = c("DensMoradBanheiro", "DensDomiciliar"),
    check.keys = TRUE
)
```


```{r SocEconComparData, echo = FALSE}
SocEconComparData <-
  IndicsComparData[, c(names(IndicsComparData['SocioEcon']),
                       names(sort(abs(IndicsCorrMtx$r[3,-3]),
                                  decreasing = TRUE)))]
SocEconCorrMtx <- rcorr(as.matrix(SocEconComparData))

kable(
    data.frame(
        var = names(SocEconCorrMtx$r[1, -1]),
        r = formatC(SocEconCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(SocEconCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)
```


```{r DimensionsData, echo = FALSE}
DimensionsData <-
    data.frame(CodMunicipio = IndicatorsData$CodMunicipio, 
               IDEB = IndicatorsData$IDEB,
               ENEM = IndicatorsData$ENEM,
               SocioEcon = IndicatorsData$SocioEcon,
               TMDeslocamento = IndicatorsData$TMDeslocamento)
DimensionsData$D1 <- IndicatorsData$TDeslocamento
DimensionsData$D2 <-
    (IndicatorsData$Arborizacao +
     IndicatorsData$EsgCeuAberto + 
     IndicatorsData$LixoAcumulado) / 3
DimensionsData$D3 <-
    (IndicatorsData$AglomSubnormal + 
     IndicatorsData$DensDomiciliar + 
     IndicatorsData$DensMoradBanheiro + 
     IndicatorsData$MaterialParedes + 
     IndicatorsData$EspecDomicilio) / 5
DimensionsData$D4 <-
    (IndicatorsData$AtendimentoAgua + 
     2 * IndicatorsData$AtendimentoEsgoto + 
     IndicatorsData$ColetaLixo + 
     IndicatorsData$AtendimentoEnergia) / 5
DimensionsData$D5 <-
    (IndicatorsData$IluminacaoPublica + 
     IndicatorsData$Pavimentacao + 
     IndicatorsData$Calcada + 
     IndicatorsData$MeiofioGuia + 
     IndicatorsData$BueiroBocadelobo + 
     IndicatorsData$RampaCadeirantes + 
     IndicatorsData$IdentLogradouro) / 7
```

```{r DimsComparData, echo = FALSE}
DimsComparData <- subset(DimensionsData, select = -CodMunicipio)
psych::describe(DimsComparData)

DimsCorrMtx <- rcorr(as.matrix(DimsComparData))
DimsComparData <- DimsComparData[, c(names(DimsComparData[1]),
                         names(sort(abs(DimsCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
DimsCorrMtx <- rcorr(as.matrix(DimsComparData))
CairoPNG(
        filename = paste0("images/", "DimCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(DimsCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black', 
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(DimsCorrMtx$r[1, -1]),
        r = formatC(DimsCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(DimsCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)

DimsCorrelation <- corr.test(DimsComparData, method = "spearman")

kable(DimsCorrelation$r, digits = 2)
kable(formatC(DimsCorrelation$p, format = "E", 2))
```

```{r IBEUData, echo = FALSE}
IBEUData <-
    data.frame(CodMunicipio = IndicatorsData$CodMunicipio, 
               IDEB = IndicatorsData$IDEB,
               ENEM = IndicatorsData$ENEM,
               SocioEcon = IndicatorsData$SocioEcon,
               TMDeslocamento = IndicatorsData$TMDeslocamento)
IBEUData$IBEU <-
    (DimensionsData$D1 + 
     DimensionsData$D2 + 
     DimensionsData$D3 + 
     DimensionsData$D4 + 
     DimensionsData$D5) / 5
```

```{r IBEUComparData, echo = FALSE}

IBEUComparData <- subset(IBEUData, select = -CodMunicipio)

IBEUCorrMtx <- rcorr(as.matrix(IBEUComparData))

IBEUComparData <- IBEUComparData[, c(names(IBEUComparData[1]),
                         names(sort(abs(IBEUCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
IBEUCorrMtx <- rcorr(as.matrix(IBEUComparData))

CairoPNG(
        filename = paste0("images/", "IBEUCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(IBEUCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black', 
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(IBEUCorrMtx$r[1, -1]),
        r = formatC(IBEUCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(IBEUCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)

IBEUCorrelation <- corr.test(IBEUComparData, method = "spearman")

kable(IBEUCorrelation$r, digits = 2)
kable(formatC(IBEUCorrelation$p, format = "E", 2))
```

```{r merging, echo = FALSE}
DimensionsDF <- merge(DimensionsData,
                      subset(IDlist, select = -nome),
                      by = 'CodMunicipio',
                      all.y = FALSE)
DimensionsDF <- DimensionsDF[!duplicated(DimensionsDF$CodMunicipio), ]

IBEUDF <- merge(IBEUData,
                subset(IDlist, select = -nome),
                by = 'CodMunicipio',
                all.y = FALSE)
IBEUDF <- IBEUDF[!duplicated(IBEUDF$CodMunicipio),]
IBEUDF <- subset(IBEUDF, select = c('id', 'IDEB', 'IBEU'))
```

```{r Maps}
scale_x_longitude <- function(xmin = -180,
                              xmax = 180,
                              step = 1,
                              ...) {
    xbreaks <- seq(xmin, xmax, step)
    xlabels <-
        unlist(lapply(xbreaks, function(x)
            ifelse(
                x < 0, parse(text = paste0(-x, "^o", "*W")), 
                ifelse(x > 0, parse(text = paste0(x, "^o", "*E")), 
                       x
                       )
                )
            ))
    return(
        scale_x_continuous(
            "Longitude",
            breaks = xbreaks,
            labels = xlabels,
            expand = c(0, 0),
            ...
        )
    )
}
scale_y_latitude <- function(ymin = -90,
                             ymax = 90,
                             step = 0.5,
                             ...) {
    ybreaks <- seq(ymin, ymax, step)
    ylabels <-
        unlist(lapply(ybreaks, function(x)
            ifelse(
                x < 0, parse(text = paste0(-x, "^o", "*S")), 
                ifelse(x > 0, parse(text = paste0(x, "^o", "*N")), 
                       x
                       )
                )
            ))
    return(scale_y_continuous(
        "Latitude",
        breaks = ybreaks,
        labels = ylabels,
        expand = c(0, 0),
        ...
    ))
}

choroplMap <- function(datafile, xvarname, yvarname, picfilename, percflag = TRUE) {
        CairoPNG(
                filename = paste0("images/", picfilename),
                width = 3600,
                height = 3600,
                dpi = 600,
                bg = "white"
        )
        
        choroMap <- ggplot()
        choroMap <- choroMap + geom_map(
                data = datafile,
                aes(map_id = id,
                    fill = datafile[, xvarname],
                    fill2 = datafile[, yvarname]
                    ),
                map = municipiosDF,
                color = 'NA'
        )
        if (percflag)
                choroMap <-
                choroMap + scale_fill_colorplane(
                        limits_y = c(0, 1),
                        labels_y = percent,
                        axis_title = xvarname,
                        axis_title_y = yvarname,
                        color_projection = "YUV",
                        Y = 0.4
                )
        else
                choroMap <-
                choroMap + scale_fill_colorplane(
                        axis_title = xvarname,
                        axis_title_y = yvarname,
                        color_projection = "YUV",
                        Y = 0.4
                )
        choroMap <- choroMap + expand_limits(x = municipiosDF$long,
                                             y = municipiosDF$lat)
        choroMap <- choroMap + coord_map()
        choroMap <- choroMap + scale_x_longitude(xmin=-80, xmax=-30, step=10)
        choroMap <- choroMap + scale_y_latitude(ymin=-40, ymax=+10, step=10)
        choroMap <- choroMap + theme_minimal()
        choroMap <- choroMap + scalebar(
                municipiosDF,
                x.min = -80,
                x.max = -30,
                y.min = -40,
                y.max = +10,
                dist = 500,
                location = "bottomright",
                anchor = c(x = -35, y = -30),
                dd2km = TRUE,
                model = 'WGS84',
                st.size = 3
        )

        north2(choroMap,
                scale = 0.15,
                x = 0.8,
                symbol = 3)
        
        choroMap

        dev.off()

}

choroplMap(DimensionsDF, 'IDEB', 'D1', "D1Map.png") 

choroplMap(DimensionsDF, 'IDEB', 'D2', "D2Map.png")

choroplMap(DimensionsDF, 'IDEB', 'D3', "D3Map.png")

choroplMap(DimensionsDF, 'IDEB', 'D4', "D4Map.png")

choroplMap(DimensionsDF, 'IDEB', 'D5', "D5Map.png")

choroplMap(DimensionsDF, 'IDEB', 'TMDeslocamento', "TMDeslocMap.png", percflag = FALSE)

choroplMap(DimensionsDF, 'ENEM', 'SocioEcon', "SocEconMap.png", percflag = FALSE)

choroplMap(IBEUDF, 'IDEB', 'IBEU', "IBEUMap.png")
```




## References
```{r}
citations()
```
- Harvey, D. (1971). *Social Justice and the City*. London: Edward Arnold. 
- Ribeiro, L. C. de Q., Koslinski, M. C., Zuccarelli, C., & Christovão, A. C. (2016). Desafios Urbanos à Democratização do Acesso às Oportunidades Educacionais nas Metrópoles Brasileiras. *Educação & Sociedade*, *37*(134), 171-193. https://doi.org/10.1590/ES0101-73302016157093
- Ribeiro, L. C. de Q., & Ribeiro, M. G. (2013). *IBEU - Indice de Bem-Estar Urbano*. Rio de Janeiro: Letra Capital. Retrieved from http://www.observatoriodasmetropoles.net/images/abook_file/ibeu_livro.pdf


