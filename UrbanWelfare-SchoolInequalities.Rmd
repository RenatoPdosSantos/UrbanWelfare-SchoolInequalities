---
title: "Electricity, Water Supply, and Sanitation"
author: "Renato P. dos Santos"
date: "17 July 2017"
output: word_document
---

```{r Setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract
Despite the tantalising evidence for Brazilian students’ socioeconomic status being one of the leading single predictors of their school achievements (dos Santos, 2017), this measure does not account for the complexity of the ‘real income’ (Harvey, 1971) that the city must offer people in terms of material conditions of life, in the form of housing, transportation and quality education, to be provided and used collectively. This concept allows one to evaluate better how the uneven distribution of urban conditions among social groups in the city favours social inequalities (Ribeiro & Ribeiro, 2013, pp. 9–11). Yet, the changing Brazilian urban reality segregates people in socio-spatial terms and distributes urban public resources unfairly, threatening student’s access to the structure of educational opportunities and causing school inequalities (Ribeiro, Koslinski, Zuccarelli, & Christovão, 2016). For that reason, we expanded the study of Ribeiro et al. (2016) in Brazilian metropolises, using data from Brazil’s 2010 Population and Housing Census made available via the SIDRA system , to investigate each of the 20 indicators that compose the Urban Welfare Index (IBEU) (Ribeiro & Ribeiro, 2013). Factors such as existence of public lighting, paving, sidewalk, wheelchair ramp, open sewage and garbage accumulated around the homes, as well as electricity and water supply, sanitation, the material of the walls of the houses, and the number of residents per bedroom and bathroom as predictors of school achievements as measured using their average ENEM (National High School Exam) outcomes and IDEB (Basic Education Development Index) results are discussed using Data Science methods. Results show that the Urban Housing Conditions dimension of IBEU has a higher correlation with IDEB, while students’ socioeconomic status correlates better with ENEM than with IDEB, relations that are clearly illustrated by means of bivariate choropleth maps across each of the 5,564 Brazilian municipalities. This seems to confirm that the uneven distribution of urban conditions reduces educational opportunities and engenders social inequalities that are incompatible with a sustainable society.
Keywords

```{r Environment, echo = FALSE}
# Enviroment values
R.version <- sessionInfo()$R.version$version.string
RStudio.version <- as.character(RStudio.Version()$version[1])
OS.version <- sessionInfo()$running
platform <- sessionInfo()$platform
```

```{r Packages, echo = FALSE}
suppressMessages(library(broom)) # Convertion of statistical analysis objects into tidy data frames
suppressMessages(library(maptools)) # Reading and Handling Spatial Objects
suppressMessages(library(mapproj)) # Convertion of latitude/longitude into projected coordinates
suppressMessages(library(rgdal)) # Bindings for the Geospatial Data Abstraction Library
suppressMessages(library(ggplot2)) # Elegant data visualisations using the grammar of graphics
suppressMessages(library(readr)) # Fast and friendly reading of '.csv', '.tsv', and '.fwf' data
suppressMessages(library(plyr)) # Tools for Splitting, Applying and Combining Data. Required for XGBoost Method (must be loaded before dplyr)
suppressMessages(library(gpclib)) # General polygon clipping library for R
suppressMessages(library(rgeos)) # Interface to Geometry Engine - Open Source (GEOS)
suppressMessages(library(ggsn)) # North Symbols and Scale Bars for Maps Created with 'ggplot2' or 'ggmap'
suppressMessages(library(digest)) # Create compact hash digests of R objects
suppressMessages(library(psych)) # Functions for analyzing data at multiple levels
suppressMessages(library(colorplaner)) # A 'ggplot2' extension to create a bivariate choropleth in R with multivariate color scales.
suppressMessages(library(Hmisc)) # Miscellaneous useful functions for data analysis
suppressMessages(library(knitr)) # General-purpose tool for dynamic report generation in R
suppressMessages(library(corrplot)) # Graphical display of correlation matrix
suppressMessages(library(extrafont)) # Tools to using system TrueType fonts 
windowsFonts(Arial=windowsFont("TT Arial"))
suppressMessages(library(Cairo)) # Library for  high-quality output
suppressMessages(library(rmarkdown)) # Dynamic documents for R

citations <- function(includeURL = TRUE, includeRStudio = TRUE) {
    if(includeRStudio == TRUE) {
        ref.rstudio <- RStudio.Version()$citation
        if(includeURL == FALSE) {
            ref.rstudio$url = NULL;
        }
        print(ref.rstudio, style = 'text')
        cat('\n')
    }

    cit.list <- c('base', names(sessionInfo()$otherPkgs))
    for(i in 1:length(cit.list)) {
        ref <- citation(cit.list[i])
        if(includeURL == FALSE) {
            ref$url = NULL;
        }
        print(ref, style = 'text')
        cat('\n')
    }
}

# ++++++++++++++++++++++++++++
# flattenCorrMatrix
# Source: http://www.sthda.com/english/wiki/correlationmatrixaquickstartguidetoanalyzeformatandvisualizeacorrelationmatrixusingrsoftware
# ++++++++++++++++++++++++++++
# cormat : matrix of the correlation coefficients
# pmat : matrix of the correlation p‐values
flattenCorrMatrix <- function(cormat, pmat, digits = 2) {
    ut <- upper.tri(cormat)
    data.frame(
        row = rownames(cormat)[row(cormat)[ut]],
        column = rownames(cormat)[col(cormat)[ut]],
        cor = formatC((cormat)[ut], format = "f", digits),
        p = formatC((pmat[ut]), format = "E", digits)
    )
}

# Indices standardization. Centers it around its minimum if it is a
# positive index, around its maximum otherwise. Scales to its range in
# any case.
IndicStand <- function(Indic, negative = FALSE) {
        if (negative) {
                center <- max(Indic, na.rm = TRUE)
                scale <-
                        min(Indic, na.rm = TRUE) - max(Indic, na.rm = TRUE)
        } else {
                center <- min(Indic, na.rm = TRUE)
                scale <-
                        max(Indic, na.rm = TRUE) - min(Indic, na.rm = TRUE)
        }
        (Indic - center) / scale
}
```

## Composition of the IBEU index

Five dimensions (D1 - D5), each composed of one to seven indices
D1: Mobilidade Urbana: 
1.	Deslocamento casa-trabalho
D2: Condições Ambientais Urbanas:
2.	Arborização no entorno dos domicílios
3.	Esgoto a céu aberto no entorno dos domicílios
4.	Lixo acumulado no entorno dos domicílios
D3: Condições Habitacionais Urbanas:
5.	Aglomerado subnormal
6.	Densidade domiciliar: número de pessoas no domicílio por número de dormitórios
7.	Densidade morador/banheiro
8.	Material das paredes dos domicílios
9.	Espécie dos domicílios
D4: Atendimento de Serviços Coletivos Urbanos:
10.	Atendimento de água
11.	Atendimento de esgoto
12.	Atendimento de energia
13.	Coleta de lixo
D5: Infraestrutura Urbana:
14.	Iluminação pública
15.	Pavimentação
16.	Calçada
17.	Meio-fio/Guia
18.	Bueiro ou boca de lobo
19.	Rampa para cadeirantes
20.	Identificação de Logradouro

Polygons of Brazilian States and Municipalities. Retrieved from: http://www.gmapas.com/poligonos-ibge/municipios-do-brasil

```{r Polygons, echo = FALSE}
# Polygons of Brazilian States and Municipalities
municipiosFile <- "data/municipios.kml"
layersList <- ogrListLayers(municipiosFile)
municipios <- readOGR(
    municipiosFile,
    layer = layersList[1],
    stringsAsFactors = FALSE,
    encoding = "UTF-8", 
    use_iconv = TRUE
)
# Transform to a data frame for ggplot2 graphics facility
municipiosDF <- tidy(municipios)

## Order matters for geom_path!
municipiosDF <- municipiosDF[order(municipiosDF$order),]

# Extract list of ID's and municipalities names
IDlist <- data.frame(
        id = sapply(municipios@polygons, function(x) slot(x, 'ID')),
        nome = municipios@data$Name,
        stringsAsFactors = FALSE
)
keepList <- IDlist$id[IDlist$nome != ""]
IDlist <- subset(IDlist, (id %in% keepList))
municipiosDF <- subset(municipiosDF, (id %in% keepList))
```

Table of Codes of Municipalities. Retrieved from: http://concla.ibge.gov.br/classificacoes/por-tema/codigo-de-areas/codigo-de-areas.html

```{r geocodigos}
# Geocódigos do IBGE
codigosFile <- "data/municipios-codes.csv"
# Read only relevant variables
codigosDF <- read_csv2(
    codigosFile,
    col_names = TRUE,
    cols_only(UF = col_character(),
              Municipio = col_character(),
              Nome_Municipio = col_character()),
    locale(encoding = "UTF-8")
)
codigosDF$CodMunicipio <- as.numeric(paste0(codigosDF$UF, codigosDF$Municipio))
codigosDF <- subset(codigosDF, !duplicated(codigosDF$CodMunicipio))
codigosDF <- codigosDF[order(codigosDF$CodMunicipio),]
codigosDF <- rename(codigosDF, c("Nome_Municipio" = "nome"))
codigosDF$UF <- NULL
codigosDF$Municipio <- NULL

IDlist$CodMunicipio <- codigosDF$CodMunicipio
```

```{r Ideb}
# Estatísticas do Ideb 2011
IdebDF <- as.data.frame(read_csv(
    "data/IDEB2011.csv",
    col_names = TRUE, 
    na = c("-"),
    cols_only(
        Codigo = col_integer(),
        Ideb = col_number()
    )
))
IdebDF <- rename(IdebDF, c('Codigo' = 'CodMunicipio'))

# Average over municipality
IdebDF <- aggregate(Ideb ~ Codigo,
                    data = IdebDF, 
                    FUN = mean)
```

```{r Enem, echo = FALSE}
# File layout
CensoFileLayout <- as.data.frame(matrix(
    data = c(
        c("NU_ANO_CENSO", "NULL"),
        c("ID_TURMA", "NULL"),
        c("NO_TURMA", "NULL"),
        c("TX_HR_INICIAL", "NULL"),
        c("TX_MI_INICIAL", "NULL"),
        c("NU_DURACAO_TURMA", "NULL"),
        c("NU_MATRICULAS", "NULL"),
        c("TP_MEDIACAO_DIDATICO_PEDAGO", "NULL"),
        c("IN_ESPECIAL_EXCLUSIVA", "numeric"),
        c("IN_REGULAR", "numeric"),
        c("IN_EJA", "NULL"),
        c("IN_PROFISSIONALIZANTE", "NULL"),
        c("EtapaEnsino", "numeric"),
        c("CO_CURSO_EDUC_PROFISSIONAL", "NULL"),
        c("TP_TIPO_TURMA", "NULL"),
        c("IN_MAIS_EDUCACAO", "NULL"),
        c("NU_DIAS_ATIVIDADE", "NULL"),
        c("IN_DIA_SEMANA_DOMINGO", "NULL"),
        c("IN_DIA_SEMANA_SEGUNDA", "NULL"),
        c("IN_DIA_SEMANA_TERCA", "NULL"),
        c("IN_DIA_SEMANA_QUARTA", "NULL"),
        c("IN_DIA_SEMANA_QUINTA", "NULL"),
        c("IN_DIA_SEMANA_SEXTA", "NULL"),
        c("IN_DIA_SEMANA_SABADO", "NULL"),
        c("CO_TIPO_ATIVIDADE_1", "NULL"),
        c("CO_TIPO_ATIVIDADE_2", "NULL"),
        c("CO_TIPO_ATIVIDADE_3", "NULL"),
        c("CO_TIPO_ATIVIDADE_4", "NULL"),
        c("CO_TIPO_ATIVIDADE_5", "NULL"),
        c("CO_TIPO_ATIVIDADE_6", "NULL"),
        c("IN_BRAILLE", "NULL"),
        c("IN_RECURSOS_BAIXA_VISAO", "NULL"),
        c("IN_PROCESSOS_MENTAIS", "NULL"),
        c("IN_ORIENTACAO_MOBILIDADE", "NULL"),
        c("IN_SINAIS", "NULL"),
        c("IN_COMUNICACAO_ALT_AUMENT", "NULL"),
        c("IN_ENRIQ_CURRICULAR", "NULL"),
        c("IN_SOROBAN", "NULL"),
        c("IN_INFORMATICA_ACESSIVEL", "NULL"),
        c("IN_PORT_ESCRITA", "NULL"),
        c("IN_AUTONOMIA_ESCOLAR", "NULL"),
        c("IN_DISC_QUIMICA", "NULL"),
        c("IN_DISC_FISICA", "NULL"),
        c("IN_DISC_MATEMATICA", "NULL"),
        c("IN_DISC_BIOLOGIA", "NULL"),
        c("IN_DISC_CIENCIAS", "NULL"),
        c("IN_DISC_LINGUA_PORTUGUESA", "NULL"),
        c("IN_DISC_LINGUA_INGLES", "NULL"),
        c("IN_DISC_LINGUA_ESPANHOL", "NULL"),
        c("IN_DISC_LINGUA_FRANCES", "NULL"),
        c("IN_DISC_LINGUA_INDIGENA", "NULL"),
        c("IN_DISC_LINGUA_OUTRA", "NULL"),
        c("IN_DISC_ARTES", "NULL"),
        c("IN_DISC_EDUCACAO_FISICA", "NULL"),
        c("IN_DISC_HISTORIA", "NULL"),
        c("IN_DISC_GEOGRAFIA", "NULL"),
        c("IN_DISC_FILOSOFIA", "NULL"),
        c("IN_DISC_ENSINO_RELIGIOSO", "NULL"),
        c("IN_DISC_ESTUDOS_SOCIAIS", "NULL"),
        c("IN_DISC_SOCIOLOGIA", "NULL"),
        c("IN_DISC_EST_SOCIAIS_SOCIOLOGIA", "NULL"),
        c("IN_DISC_INFORMATICA_COMPUTACAO", "NULL"),
        c("IN_DISC_PROFISSIONALIZANTE", "NULL"),
        c("IN_DISC_ATENDIMENTO_ESPECIAIS", "NULL"),
        c("IN_DISC_DIVER_SOCIO_CULTURAL", "NULL"),
        c("IN_DISC_LIBRAS", "NULL"),
        c("IN_DISC_PEDAGOGICAS", "NULL"),
        c("IN_DISC_OUTRAS", "NULL"),
        c("CodEntidade", "numeric"),
        c("CO_REGIAO", "NULL"),
        c("CO_MESORREGIAO", "NULL"),
        c("CO_MICRORREGIAO", "NULL"),
        c("CO_UF", "NULL"),
        c("CodMunicipio", "numeric"),
        c("CO_DISTRITO", "NULL"),
        c("TP_DEPENDENCIA", "NULL"),
        c("TP_LOCALIZACAO", "NULL"),
        c("TP_CATEGORIA_ESCOLA_PRIVADA", "NULL"),
        c("IN_CONVENIADA_PP", "NULL"),
        c("TP_CONVENIO_PODER_PUBLICO", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_EMP", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_ONG", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIND", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIST_S", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_S_FINS", "NULL"),
        c("TP_REGULAMENTACAO", "NULL"),
        c("TP_LOCALIZACAO_DIFERENCIADA", "NULL"),
        c("IN_EDUCACAO_INDIGENA", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(CensoFileLayout) <- c('Fieldname', 'ColType')

EnemFileLayout <- as.data.frame(matrix(
    data = c(
        c("CodEntidade", "numeric"),
        c("NomeEntidade", "NULL"),
        c("UF", "NULL"),
        c("Munic", "NULL"),
        c("Admin", "NULL"),
        c("Local", "NULL"),
        c("NumAlunos", "numeric"),
        c("Porte", "NULL"),
        c("PartENEM", "NULL"),
        c("TaxPart", "NULL"),
        c("PartNE", "NULL"),
        c("Perm", "NULL"),
        c("SocioEcon", "character"),
        c("FFormDoc", "NULL"),
        c("FormDoc", "NULL"),
        c("Aprov", "NULL"),
        c("Reprov", "NULL"),
        c("Aband", "NULL"),
        c("Top30", "NULL"),
        c("Media", "numeric"),
        c("Nivel1", "NULL"),
        c("Nivel2", "NULL"),
        c("Nivel3", "NULL"),
        c("Nivel4", "NULL"),
        c("Nivel5", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(EnemFileLayout) <- c('Fieldname', 'ColType')

readDataFile <-
        function(filename,
                 header,
                 sep,
                 FileLayout,
                 skip,
                 nrows,
                 comment.char
                 ) {
                # Read datafile
                if (!file.exists(paste0("data/", filename)))
                        stop(paste("File", filename, "not found!"))
                readData <- read.table(
                        file = paste0("data/", filename),
                        header = header,
                        sep = sep,
                        colClasses = FileLayout$ColType,
                        skip = skip,
                        nrows = nrows,
                        comment.char = comment.char,
                        stringsAsFactors = FALSE,
                        quote=""
                )
                if (nrow(readData) == 0) {
                        stop(paste("Empty file", filename, "!"))
                } else {
                        print(paste(nrow(readData), "lines read."))
                }
                colnames(readData) <- FileLayout$Fieldname[which(FileLayout$ColType != "NULL")]
                readData
        }

CensoData <- 
        readDataFile( 
                filename = "TURMAS.CSV",
                header = TRUE,
                sep = "|",
                FileLayout = CensoFileLayout,
                skip = 0,
                nrows = 3000000,
                comment.char = ""
        )

CensoData <- subset(CensoData, IN_REGULAR == 1 & IN_ESPECIAL_EXCLUSIVA == 0)
CensoData$IN_ESPECIAL_EXCLUSIVA <- NULL
CensoData$IN_REGULAR <- NULL
EnsMedio <- c(25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 64, 67, 71, 74)
CensoData <- subset(CensoData, EtapaEnsino %in% EnsMedio)
CensoData$EtapaEnsino <- NULL
CensoData <- unique(CensoData)
CensoData <- CensoData[!duplicated(CensoData$CodEntidade), ]

EnemData <- 
        readDataFile(
                filename = "ENEM2015_CHumanas.csv",
                header = TRUE,
                sep = ";",
                FileLayout = EnemFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
EnemData <- rename(EnemData, c("Media" = "CHumanas"))

NewEnemData <- 
        readDataFile(
                filename = "ENEM2015_CNatureza.csv",
                header = TRUE,
                sep = ";",
                FileLayout = EnemFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewEnemData <- rename(NewEnemData, c('Media' = 'CNatureza'))
EnemData <- merge(EnemData, NewEnemData[,c('CodEntidade', 'CNatureza')], by = 'CodEntidade')

NewEnemData <- 
        readDataFile(
                filename = "ENEM2015_Linguagens.csv",
                header = TRUE,
                sep = ";",
                FileLayout = EnemFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewEnemData <- rename(NewEnemData, c('Media' = 'Linguagens'))
EnemData <- merge(EnemData, NewEnemData[,c('CodEntidade', 'Linguagens')], by = 'CodEntidade')

NewEnemData <- 
        readDataFile(
                filename = "ENEM2015_Redacao.csv",
                header = TRUE,
                sep = ";",
                FileLayout = EnemFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewEnemData <- rename(NewEnemData, c('Media' = 'Redacao'))
EnemData <- merge(EnemData, NewEnemData[,c('CodEntidade', 'Redacao')], by = 'CodEntidade')

NewEnemData <- 
        readDataFile(
                filename = "ENEM2015_Matematica.csv",
                header = TRUE,
                sep = ";",
                FileLayout = EnemFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewEnemData <- rename(NewEnemData, c('Media' = 'Matematica'))
EnemData <- merge(EnemData, NewEnemData[,c('CodEntidade', 'Matematica')], by = 'CodEntidade')

EnemData <- subset(EnemData, SocioEcon != "Sem informação") 

EnemDF <- merge(CensoData, EnemData, by = 'CodEntidade', all = FALSE)

# Tansformations
EnemDF$SocioEcon <-
        factor(
                EnemDF$SocioEcon,
                levels = c(
                        "Muito Baixo",
                        "Baixo",
                        "Médio Baixo",
                        "Médio",
                        "Médio Alto",
                        "Alto",
                        "Muito alto"
                ),
                ordered = TRUE
        )

EnemDF$CHumanas <- EnemDF$CHumanas * EnemDF$NumAlunos
EnemDF$CNatureza <- EnemDF$CNatureza * EnemDF$NumAlunos
EnemDF$Linguagens <- EnemDF$Linguagens * EnemDF$NumAlunos
EnemDF$Redacao <- EnemDF$Redacao * EnemDF$NumAlunos
EnemDF$Matematica <- EnemDF$Matematica * EnemDF$NumAlunos
EnemDF$SocioEcon <- as.numeric(EnemDF$SocioEcon) * EnemDF$NumAlunos

EnemDF <-
        aggregate(
                cbind(
                        NumAlunos,
                        SocioEcon,
                        CHumanas,
                        CNatureza,
                        Linguagens,
                        Redacao,
                        Matematica
                ) ~ CodMunicipio,
                data = EnemDF,
                FUN = sum,
                na.action = na.omit
        )

EnemDF$SocioEcon <- EnemDF$SocioEcon / EnemDF$NumAlunos
EnemDF$CHumanas <- EnemDF$CHumanas / EnemDF$NumAlunos
EnemDF$CNatureza <- EnemDF$CNatureza / EnemDF$NumAlunos
EnemDF$Linguagens <- EnemDF$Linguagens / EnemDF$NumAlunos
EnemDF$Redacao <- EnemDF$Redacao / EnemDF$NumAlunos
EnemDF$Matematica <- EnemDF$Matematica / EnemDF$NumAlunos

EnemDF$NumAlunos <- NULL

EnemDF$Enem <- rowMeans(EnemDF[,c('CHumanas', 'CNatureza', 'Linguagens', 'Redacao', 'Matematica')], na.rm = TRUE)
EnemDF <- subset(EnemDF, select = c('CodMunicipio', 'Enem', 'SocioEcon'))
```

```{r IBEU, echo = FALSE}
# Read only relevant variables
# Ler os data a partir do arquivo .xlsx.

# O indicador de deslocamento casa-trabalho é construído a partir do
# tempo de deslocamento que as pessoas ocupadas que trabalham fora do
# domicílio, e retornam diariamente para casa, utilizam no trajeto de
# ida entre o domicílio de residência e o local de trabalho. É 
# considerado como tempo de deslocamento adequado quando as pessoas
# gastam até 1 hora por dia no trajeto casa-trabalho. Assim,
# utiliza-se proporção de pessoas ocupadas que trabalham fora do
# domicílio e retornam para casa diariamente que gastam até 1 hora no
# trajeto casa-trabalho.
# Obs: Neste trabalho, em vez disso, calculou-se a frequência média em
# cada uma das categorias 'Até cinco minutos', 'De seis minutos até
# meia hora', 'Mais de meia hora até uma hora', 'Mais de uma hora até
# duas horas' e 'Mais de duas horas', calculada a inversa da
# distribuição acumulada da distribuição normal para cada um desses
# valores e, finalmente, computado o índice médio pelo produto dos
# totais de domicílios em cada categoria por esses valores da inversa
# da normal, dividido pelo total de domicílios em cada município.
tempo_deslocDF <- as.data.frame(read_csv(
    "data/01_tempo_deslocamento.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
tempo_deslocDF <-
        rename(tempo_deslocDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'TDeslocamento'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
tempo_deslocDF$TDeslocamento <-
        IndicStand(tempo_deslocDF$TDeslocamento, negative = FALSE)

# O indicador de arborização no entorno dos domicílios é obtido a
# partir da proporção de pessoas que moram em domicílios cujo entorno
# possui arborização.
arborizacaoDF <- as.data.frame(read_csv(
    "data/02_arborizacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
arborizacaoDF <-
        rename(arborizacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Arborização'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
arborizacaoDF$Arborizacao <-
        IndicStand(arborizacaoDF$Arborizacao, negative = FALSE)

# O indicador de esgoto a céu aberto no entorno dos domicílios é
# construído a partir da proporção de pessoas que moram em domicílios
# cujo entorno não possui esgoto a céu aberto.
esgoto_abertoDF <- as.data.frame(read_csv(
    "data/03_esgoto_ceu_aberto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
esgoto_abertoDF <-
        rename(esgoto_abertoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EsgCeuAberto'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
esgoto_abertoDF$EsgCeuAberto <-
        IndicStand(esgoto_abertoDF$EsgCeuAberto, negative = FALSE)

# O indicador de lixo acumulado no entorno dos domicílios é obtido a
# partir da proporção de pessoas que moram em domicílios cujo entorno
# não possui lixo acumulado.
lixo_acumDF <- as.data.frame(read_csv(
    "data/04_lixo_acumulado.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
lixo_acumDF <-
        rename(lixo_acumDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'LixoAcumulado'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
lixo_acumDF$LixoAcumulado <-
        IndicStand(lixo_acumDF$LixoAcumulado, negative = FALSE)

# O indicador aglomerado subnormal corresponde à proporção de pessoas
# da área de ponderação que não moram em aglomerado subnormal.
aglom_subnormDF <- as.data.frame(read_csv(
    "data/05_aglomerado_subnormal.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
aglom_subnormDF <-
        rename(aglom_subnormDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AglomSubnormal'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
aglom_subnormDF$AglomSubnormal <-
        IndicStand(aglom_subnormDF$AglomSubnormal, negative = FALSE)

# O indicador de densidade domiciliar é construído a partir da razão
# entre número de pessoas no domicílio e número de dormitório.
# Considerou-se como densidade domiciliar adequada quando havia até 2
# pessoas por dormitório. O indicador de densidade domiciliar foi
# considerado como a proporção de pessoas que estão em domicílios cuja
# densidade é de até 2 pessoas por dormitório.
# Obs: Neste trabalho, em vez disso, calculou-se o índice médio de
# pessoas por dormitório por município, computado pelo produto dos
# totais de domicílios pelas categorias de pessoas por dormitório,
# '1', '2', '3', '4', dividido pelo total de domicílios em cada
# município.
dens_domicilDF <- as.data.frame(read_csv(
    "data/06_densidade_domiciliar.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_domicilDF <-
        rename(dens_domicilDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'DensDomiciliar'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
dens_domicilDF$DensDomiciliar <-
        IndicStand(dens_domicilDF$DensDomiciliar, negative = FALSE)

# No indicador de densidade domiciliar morador/banheiro, considerou-se
# como adequado o domicílio que possui até 4 pessoas por banheiro. 
# Assim, o indicador de densidade morador/banheiro corresponde à 
# proporção de pessoas que estão em domicílio de até 4 pessoas por 
# banheiro. Obs: Neste trabalho, em vez disso, calculou-se o índice
# médio de moradores por banheiro por município, computado pelo
# produto dos totais de domicílios pelas proporções de moradores por
# banheiro existente no domicílio, dividido pelo total de domicílios
# em cada município.
dens_mor_banhDF <- as.data.frame(read_csv(
    "data/07_densidade_morador-banheiro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_mor_banhDF <-
        rename(dens_mor_banhDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'DensMoradBanheiro'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
dens_mor_banhDF$DensMoradBanheiro <-
        IndicStand(dens_mor_banhDF$DensMoradBanheiro, negative = FALSE)

# No indicador de material das paredes dos domicílios, considerou-se
# como adequado o domicílio cujas paredes externas são do tipo de
# alvenaria com revestimento ou madeira apropriada para construção
# (aparelhada). Neste caso, o indicador de material das paredes dos
# domicílios corresponde à proporção de pessoas que estão em
# domicílios com material das paredes adequado.
material_paredesDF <- as.data.frame(read_csv(
    "data/08_material_paredes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
material_paredesDF <-
        rename(material_paredesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MaterialParedes'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
material_paredesDF$MaterialParedes <-
        IndicStand(material_paredesDF$MaterialParedes, negative = FALSE)

# No indicador de espécie dos domicílios, considerou-se como adequado
# os domicílios do tipo casa, casa de vila ou condomínio ou
# apartamento e inadequados os domicílios do tipo habitação em casa de
# cômodo, cortiço ou cabeça de porco; tenda ou barraca, dentro de
# estabelecimento e outros (vagão, trailer, gruta, etc.). Neste caso,
# o indicador de espécie dos domicílios corresponde à proporção de
# pessoas que estão em domicílios de espécie adequada.
especie_domiciliosDF <- as.data.frame(read_csv(
    "data/09_especie_domicilios.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
especie_domiciliosDF <-
        rename(especie_domiciliosDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EspecDomicilio'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
especie_domiciliosDF$EspecDomicilio <-
        IndicStand(especie_domiciliosDF$EspecDomicilio, negative = FALSE)

# O atendimento adequado de água é considerado quando é feito por rede
# geral de água. O indicador de atendimento de água corresponde à
# proporção de pessoas que moram em domicílio com atendimento adequado
# de água.
atendimento_aguaDF <- as.data.frame(read_csv(
    "data/10_atendimento_agua.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_aguaDF <-
        rename(atendimento_aguaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoAgua'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
atendimento_aguaDF$AtendimentoAgua <-
        IndicStand(atendimento_aguaDF$AtendimentoAgua, negative = FALSE)

# O atendimento adequado de esgoto é considerado quando é feito por
# rede geral de esgoto. O indicador de atendimento de esgoto
# corresponde à proporção de pessoas que moram em domicílio com
# atendimento adequado de esgoto.
atendimento_esgotoDF <- as.data.frame(read_csv(
    "data/11_atendimento_esgoto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_esgotoDF <-
        rename(atendimento_esgotoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEsgoto'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
atendimento_esgotoDF$AtendimentoEsgoto <-
        IndicStand(atendimento_esgotoDF$AtendimentoEsgoto, negative = FALSE)

# O atendimento adequado de energia é considerado quando há energia
# elétrica de companhias distribuidoras ou de outras fontes, e sendo
# de companhia distribuidora quando houver existência de medidor. O
# indicador de atendimento de energia corresponde à proporção de
# pessoas que moram em domicílio com atendimento adequado de energia.
atendimento_energiaDF <- as.data.frame(read_csv(
    "data/12_atendimento_energia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_energiaDF <-
        rename(atendimento_energiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEnergia'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
atendimento_energiaDF$AtendimentoEnergia <-
        IndicStand(atendimento_energiaDF$AtendimentoEnergia, negative = FALSE)

# A coleta adequada de lixo é considerada quando o lixo é coletado
# diretamente por serviço de limpeza ou quando colocado em caçamba em
# serviço de limpeza. O indicador de coleta de lixo corresponde à
# proporção de pessoas que moram em domicílio com coleta adequada de
# lixo.
coleta_lixoDF <- as.data.frame(read_csv(
    "data/13_coleta_lixo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
coleta_lixoDF <-
        rename(coleta_lixoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'ColetaLixo'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
coleta_lixoDF$ColetaLixo <-
        IndicStand(coleta_lixoDF$ColetaLixo, negative = FALSE)

# O indicador de iluminação pública corresponde à proporção de pessoas
# que moram em domicílios cujo entorno possui iluminação pública. 
iluminacao_publicaDF <- as.data.frame(read_csv(
    "data/14_iluminacao_publica.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
iluminacao_publicaDF <-
        rename(iluminacao_publicaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IluminacaoPublica'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
iluminacao_publicaDF$IluminacaoPublica <-
        IndicStand(iluminacao_publicaDF$IluminacaoPublica, negative = FALSE)

# O indicador de pavimentação corresponde à proporção de pessoas que
# moram em domicílio cujo logradouro possui pavimentação (asfalto,
# cimento, paralelepípedo etc.).
pavimentacaoDF <- as.data.frame(read_csv(
    "data/15_pavimentacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
pavimentacaoDF <-
        rename(pavimentacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Pavimentacao'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
pavimentacaoDF$Pavimentacao <-
        IndicStand(pavimentacaoDF$Pavimentacao, negative = FALSE)

# O indicador de calçada corresponde à proporção de pessoas que moram
# em domicílio cuja face do logradouro onde se localiza o domicílio
# possui calçada.
calcadaDF <- as.data.frame(read_csv(
    "data/16_calcada.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
calcadaDF <-
        rename(calcadaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Calcada'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
calcadaDF$Calcada <- IndicStand(calcadaDF$Calcada, negative = FALSE)

# O indicador de meio-fio/guia corresponde à proporção de pessoas que
# moram em domicílio cuja face do logradouro onde se localiza o
# domicílio possui meio-fio/guia.
meiofio_guiaDF <- as.data.frame(read_csv(
    "data/17_meio-fio_guia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
meiofio_guiaDF <-
        rename(meiofio_guiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MeiofioGuia'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
meiofio_guiaDF$MeiofioGuia <-
        IndicStand(meiofio_guiaDF$MeiofioGuia, negative = FALSE)

# O indicador de bueiro ou boca de lobo corresponde à proporção de
# pessoas que moram em domicílios cujo entorno possui bueiro ou boca
# de lobo. A identificação de bueiro ou boca de lobo no entorno dos
# domicílios corresponde à face ou a face confrontante de onde se
# localizam os domicílios.
bueiro_boca_de_loboDF <- as.data.frame(read_csv(
    "data/18_bueiro_boca_de_lobo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
bueiro_boca_de_loboDF <-
        rename(bueiro_boca_de_loboDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'BueiroBocadelobo'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
bueiro_boca_de_loboDF$BueiroBocadelobo <-
        IndicStand(bueiro_boca_de_loboDF$BueiroBocadelobo, negative = FALSE)

# O indicador de rampa para cadeirantes corresponde à proporção de
# pessoas que moram em domicílio cuja face do logradouro onde se
# localiza o domicílio possui rampa para dar acesso às pessoas que
# utilizam cadeiras de rodas.
rampa_cadeirantesDF <- as.data.frame(read_csv(
    "data/19_rampa_cadeirantes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
rampa_cadeirantesDF <-
        rename(rampa_cadeirantesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'RampaCadeirantes'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
rampa_cadeirantesDF$RampaCadeirantes <-
        IndicStand(rampa_cadeirantesDF$RampaCadeirantes, negative = FALSE)

# O indicador de logradouros corresponde à proporção de pessoas que
# moram em domicílio onde o logradouro possui identificação.
ident_logradouroDF <- as.data.frame(read_csv(
    "data/20_identificacao_logradouro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
ident_logradouroDF <-
        rename(ident_logradouroDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IdentLogradouro'))
# Para a padronização do índice, foi considerado que este é um índice
# positivo, pois maior bem-estar corresponde a maiores valores do
# índice
ident_logradouroDF$IdentLogradouro <-
        IndicStand(ident_logradouroDF$IdentLogradouro, negative = FALSE)
```

```{r IndicatorsData, echo = FALSE}
IndicatorsData <- merge(
        IdebDF,
        EnemDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        tempo_deslocDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        arborizacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        esgoto_abertoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        lixo_acumDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
# As the 'Aglomerado subnormal' indicator was evaluated on the metropolis only, it has entries 322 only and 
IndicatorsData <- merge(
        IndicatorsData,
        aglom_subnormDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
medianValue <- median(aglom_subnormDF$AglomSubnormal)
IndicatorsData$AglomSubnormal <-
    ifelse(is.na(IndicatorsData$AglomSubnormal),
           medianValue,
           IndicatorsData$AglomSubnormal)
IndicatorsData <- merge(
        IndicatorsData,
        dens_domicilDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        dens_mor_banhDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        material_paredesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        especie_domiciliosDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_aguaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_esgotoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_energiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        coleta_lixoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        iluminacao_publicaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        pavimentacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        calcadaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        meiofio_guiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        bueiro_boca_de_loboDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        rampa_cadeirantesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        ident_logradouroDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <-
        subset(IndicatorsData, !duplicated(IndicatorsData$CodMunicipio))
```

```{r IndicsComparData, echo = FALSE}
IndicsComparData <- subset(IndicatorsData, select = -CodMunicipio)
psych::describe(IndicsComparData)

IndicsCorrMtx <- rcorr(as.matrix(IndicsComparData))
IndicsComparData <- IndicsComparData[, c(names(IndicsComparData[1]),
                         names(sort(abs(IndicsCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
IndicsCorrMtx <- rcorr(as.matrix(IndicsComparData))
CairoPNG(
        filename = paste0("images/", "IndicCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(IndicsCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black',
        tl.cex = 0.8,
        number.cex = 0.5,
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(IndicsCorrMtx$r[1, -1]),
        r = formatC(IndicsCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(IndicsCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)
```

```{r alpha, echo = FALSE}
psych::alpha(
    IndicsComparData[, -1],
    keys = c("DensMoradBanheiro", "DensDomiciliar"),
    check.keys = TRUE
)
```

```{r DimensionsData, echo = FALSE}
DimensionsData <-
    data.frame(CodMunicipio = IndicatorsData$CodMunicipio, 
               Ideb = IndicatorsData$Ideb,
               Enem = IndicatorsData$Enem,
               SocioEcon = IndicatorsData$SocioEcon)
DimensionsData$D1 <- IndicatorsData$TDeslocamento
DimensionsData$D2 <-
    (IndicatorsData$Arborizacao +
     IndicatorsData$EsgCeuAberto + 
     IndicatorsData$LixoAcumulado) / 3
DimensionsData$D3 <-
    (IndicatorsData$AglomSubnormal + 
     IndicatorsData$DensDomiciliar + 
     IndicatorsData$DensMoradBanheiro + 
     IndicatorsData$MaterialParedes + 
     IndicatorsData$EspecDomicilio) / 5
DimensionsData$D4 <-
    (IndicatorsData$AtendimentoAgua + 
     2 * IndicatorsData$AtendimentoEsgoto + 
     IndicatorsData$ColetaLixo + 
     IndicatorsData$AtendimentoEnergia) / 5
DimensionsData$D5 <-
    (IndicatorsData$IluminacaoPublica + 
     IndicatorsData$Pavimentacao + 
     IndicatorsData$Calcada + 
     IndicatorsData$MeiofioGuia + 
     IndicatorsData$BueiroBocadelobo + 
     IndicatorsData$RampaCadeirantes + 
     IndicatorsData$IdentLogradouro) / 7
```

```{r DimsComparData, echo = FALSE}
DimsComparData <- subset(DimensionsData, select = -CodMunicipio)
psych::describe(DimsComparData)

DimsCorrMtx <- rcorr(as.matrix(DimsComparData))
DimsComparData <- DimsComparData[, c(names(DimsComparData[1]),
                         names(sort(abs(DimsCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
DimsCorrMtx <- rcorr(as.matrix(DimsComparData))
CairoPNG(
        filename = paste0("images/", "DimCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(DimsCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black', 
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(DimsCorrMtx$r[1, -1]),
        r = formatC(DimsCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(DimsCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)

DimsCorrelation <- corr.test(DimsComparData, method = "spearman")

kable(DimsCorrelation$r, digits = 2)
kable(formatC(DimsCorrelation$p, format = "E", 2))
```

```{r IbeuData, echo = FALSE}
IbeuData <-
    data.frame(CodMunicipio = IndicatorsData$CodMunicipio, 
               Ideb = IndicatorsData$Ideb,
               Enem = IndicatorsData$Enem,
               SocioEcon = IndicatorsData$SocioEcon)
IbeuData$Ibeu <-
    (DimensionsData$D1 + 
     DimensionsData$D2 + 
     DimensionsData$D3 + 
     DimensionsData$D4 + 
     DimensionsData$D5) / 5
```

```{r IbeuComparData, echo = FALSE}

IbeuComparData <- subset(IbeuData, select = -CodMunicipio)

IbeuCorrMtx <- rcorr(as.matrix(IbeuComparData))

IbeuComparData <- IbeuComparData[, c(names(IbeuComparData[1]),
                         names(sort(abs(IbeuCorrMtx$r[1, -1]),
                                    decreasing = TRUE)))]
IbeuCorrMtx <- rcorr(as.matrix(IbeuComparData))

CairoPNG(
        filename = paste0("images/", "IBEUCorr.png"),
        width = 3600,
        height = 3600,
        dpi = 600,
        bg = "white"
)
corrplot(
        as.matrix(IbeuCorrMtx$r),
        addCoef.col = "black", # Add coefficient of correlation,
        method = "color",
        type = "upper",
        order = "original",
        tl.col = 'black', 
        number.digits = 2,
        diag = FALSE # hide correlation coefficient on the principal diagonal
)
dev.off()

kable(
    data.frame(
        var = names(IbeuCorrMtx$r[1, -1]),
        r = formatC(IbeuCorrMtx$r[1, -1], format = "f", 2),
        p = formatC(IbeuCorrMtx$P[1, -1], format = "E", 2)
    ),
    digits = 2,
    row.names = FALSE,
    align = c("l", "r", "r"),
    caption = "Significância das variáveis"
)

IbeuCorrelation <- corr.test(IbeuComparData, method = "spearman")

kable(IbeuCorrelation$r, digits = 2)
kable(formatC(IbeuCorrelation$p, format = "E", 2))
```

```{r merging, echo = FALSE}
DimensionsDF <- merge(DimensionsData,
                      subset(IDlist, select = -nome),
                      by = 'CodMunicipio',
                      all.y = FALSE)
DimensionsDF <- DimensionsDF[!duplicated(DimensionsDF$CodMunicipio), ]

IbeuDF <- merge(IbeuData,
                subset(IDlist, select = -nome),
                by = 'CodMunicipio',
                all.y = FALSE)
IbeuDF <- IbeuDF[!duplicated(IbeuDF$CodMunicipio),]
IbeuDF <- subset(IbeuDF, select = c('id', 'Ideb', 'Ibeu'))
```

```{r Maps}
scale_x_longitude <- function(xmin = -180,
                              xmax = 180,
                              step = 1,
                              ...) {
    xbreaks <- seq(xmin, xmax, step)
    xlabels <-
        unlist(lapply(xbreaks, function(x)
            ifelse(
                x < 0, parse(text = paste0(-x, "^o", "*W")), 
                ifelse(x > 0, parse(text = paste0(x, "^o", "*E")), 
                       x
                       )
                )
            ))
    return(
        scale_x_continuous(
            "Longitude",
            breaks = xbreaks,
            labels = xlabels,
            expand = c(0, 0),
            ...
        )
    )
}
scale_y_latitude <- function(ymin = -90,
                             ymax = 90,
                             step = 0.5,
                             ...) {
    ybreaks <- seq(ymin, ymax, step)
    ylabels <-
        unlist(lapply(ybreaks, function(x)
            ifelse(
                x < 0, parse(text = paste0(-x, "^o", "*S")), 
                ifelse(x > 0, parse(text = paste0(x, "^o", "*N")), 
                       x
                       )
                )
            ))
    return(scale_y_continuous(
        "Latitude",
        breaks = ybreaks,
        labels = ylabels,
        expand = c(0, 0),
        ...
    ))
}

choroplMap <- function(datafile, var1name, var2name, picfilename) {
        CairoPNG(
                filename = paste0("images/", picfilename),
                width = 3600,
                height = 3600,
                dpi = 600,
                bg = "white"
        )
        
        choroMap <- ggplot()
        choroMap <- choroMap + geom_map(
                data = datafile,
                aes(map_id = id,
                    fill = datafile[, var1name],
                    fill2 = datafile[, var2name]
                    ),
                map = municipiosDF,
                color = 'NA'
        )
        choroMap <-
                choroMap + scale_fill_colorplane(labels_y = scales::percent,
                                                 axis_title = var1name,
                                                 axis_title_y = var2name)
        choroMap <- choroMap + expand_limits(x = municipiosDF$long,
                                             y = municipiosDF$lat)
        choroMap <- choroMap + coord_map()
        choroMap <- choroMap + scale_x_longitude(xmin=-80, xmax=-30, step=10)
        choroMap <- choroMap + scale_y_latitude(ymin=-40, ymax=+10, step=10)
        choroMap <- choroMap + theme_minimal()
        choroMap <- choroMap + scalebar(
                municipiosDF,
                x.min = -80,
                x.max = -30,
                y.min = -40,
                y.max = +10,
                dist = 500,
                location = "bottomright",
                anchor = c(x = -35, y = -30),
                dd2km = TRUE,
                model = 'WGS84',
                st.size = 3
        )

        north2(choroMap,
                scale = 0.15,
                x = 0.8,
                symbol = 3)
        
        choroMap

        dev.off()

}

choroplMap(DimensionsDF, 'Ideb', 'D1', "D1Map.png") 

choroplMap(DimensionsDF, 'Ideb', 'D2', "D2Map.png")

choroplMap(DimensionsDF, 'Ideb', 'D3', "D3Map.png")

choroplMap(DimensionsDF, 'Ideb', 'D4', "D4Map.png")

choroplMap(DimensionsDF, 'Ideb', 'D5', "D5Map.png")

choroplMap(IbeuDF, 'Ideb', 'Ibeu', "IbeuMap.png")
```


## References
```{r}
citations()
```

- Percentual de domic?lios particulares permanentes com lixo coletado por servi?o de limpeza. IBGE. Dispon?vel em: <http://dados.gov.br/dataset/cgeo_vw_per_lixocoletadodireto>
- Percentual de domic?lios particulares permanentes com energia el?trica de companhia distribuidora e com medidor de uso exclusivo. IBGE. Dispon?vel em: <http://dados.gov.br/dataset/cgeo_vw_per_domenergiadistrimedidor_exclusivo>
- Percentual de domic?lios particulares permanentes com banheiro de uso exclusivo dos moradores ou sanit?rio e esgotamento sanit?rio via rede geral de esgoto ou pluvial ou fossa s?ptica. IBGE. Dispon?vel em: <http://dados.gov.br/dataset/cgeo_vw_per_redegeralefossa>
- Percentual de domic?lios particulares permanentes com abastecimento de ?gua da rede geral. IBGE. Dispon?vel em: <http://dados.gov.br/dataset/cgeo_vw_per_domredegeralagua>
- Estat?sticas do Ideb 2013. Ensino Fundamental Regular - Anos Finais. IDEB. Dispon?vel em: <http://portal.inep.gov.br/web/portal-ideb/planilhas-para-download>

- dos Santos, R. P. (2017). Impacto do ensino de Filosofia e Sociologia no desempenho escolar: uma análise a partir dos microdados do censo escolar do Inep. Submetido a *Pedagogia Em Foco*, v. 12.
- Harvey, D. (1971). *Social Justice and the City*. London: Edward Arnold. 
- Ribeiro, L. C. de Q., Koslinski, M. C., Zuccarelli, C., & Christovão, A. C. (2016). Desafios Urbanos à Democratização do Acesso às Oportunidades Educacionais nas Metrópoles Brasileiras. *Educação & Sociedade*, 37(134), 171–193. https://doi.org/10.1590/ES0101-73302016157093
- Ribeiro, L. C. de Q., & Ribeiro, M. G. (2013). *IBEU - Indice de Bem-Estar Urbano*. Rio de Janeiro: Letra Capital. Retrieved from http://www.observatoriodasmetropoles.net/images/abook_file/ibeu_livro.pdf


