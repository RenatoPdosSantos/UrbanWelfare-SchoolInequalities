---
title: "School Inequalities and Urban Welfare: Going beyond Socioeconomic Status with Data Science"
author: "Renato P. dos Santos, Mustafa Sahin Bülbül, and Isadora L. Lemes"
date: "31 October 2019"
output: word_document
---

```{r setup, include=FALSE}
options(java.parameters = '-Xmx5g')
options(java.parameters = '-Xms5g')
memory.limit(size = 4000)
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract
The fast-changing Brazilian urban reality segregates people in socio-spatial terms and distributes urban public resources unfairly, threatening student's access to the structure of educational opportunities and causing school inequalities. Factors such as the existence of public lighting, open sewage and garbage accumulated around the homes, as well as electricity and water supply, sanitation, and the number of residents per bathroom,  are discussed as predictors of school achievements as measured using their average IDEB (Basic Education Development Index) outcomes using Data Science methods. It was found that resident/bathroom density and the household wall material in a municipality have a higher correlation with its average school achievements than the average students' socioeconomic status, relations that are clearly illustrated through bivariate choropleth maps across all the 5,388 Brazilian municipalities with available valid data. These results are compatible with research that reveals the presence of a "neighbourhood effect," such that the distributional inequalities in infrastructure access and ultimately the notion of urban welfare reduces educational opportunities and engenders social inequalities, what is incompatible with the ideal of a sustainable society.

##Keywords
schooling inequalities; social inequalities; sustainability; urban inequalities; urban welfare; socio-spatial segregation

```{r Environment, echo = FALSE}
# Enviroment values
R.version <- sessionInfo()$R.version$version.string
RStudio.version <- as.character(RStudio.Version()$version[1])
OS.version <- sessionInfo()$running
platform <- sessionInfo()$platform
```

```{r silentLoad, echo = FALSE}
silentLoad <- function(pckg) {
  if (!(pckg %in% available.packages())) {
    return(paste("package",
                 pckg,
                 "not available!"))
  }
  if (!(pckg %in% installed.packages())) {
    suppressMessages(install.packages(pckg))
  }
  suppressMessages(library(pckg,
                           character.only = TRUE))
}
```

```{r Packages, echo = FALSE}
silentLoad("readr") # Fast and friendly reading of '.csv', '.tsv', and '.fwf' data
silentLoad("ggplot2") # Elegant data visualisations using the grammar of graphics
silentLoad("scales") # Scale functions for visualization

#suppressMessages(library(xlsx)) # XML files manipulation

silentLoad("broom") # Convertion of statistical analysis objects into tidy data frames
silentLoad("maptools") # Reading and Handling Spatial Objects
silentLoad("mapproj") # Convertion of latitude/longitude into projected coordinates
# silentLoad("rgdal") # Bindings for the Geospatial Data Abstraction Library
silentLoad("lctools") # Tools for key spatial statistics and spatial analysissilentLoad("lctools")
silentLoad("plyr") # Tools for Splitting, Applying and Combining Data. Required for XGBoost Method (must be loaded before dplyr)
#silentLoad("gpclib") # General polygon clipping library for R
silentLoad("rgeos") # Interface to Geometry Engine - Open Source (GEOS)
silentLoad("ggsn") # North Symbols and Scale Bars for Maps Created with 'ggplot2' or 'ggmap'
silentLoad("digest") # Create compact hash digests of R objects
silentLoad("psych") # Functions for analyzing data at multiple levels
# silentLoad("colorplaner") # A 'ggplot2' extension to create a bivariate choropleth in R with multivariate color scales.
# devtools::install_github("wmurphyrd/colorplaner")
silentLoad("data.table")
silentLoad("Hmisc") # Miscellaneous useful functions for data analysis
silentLoad("knitr") # General-purpose tool for dynamic report generation in R
silentLoad("corrplot") # Graphical display of correlation matrix
silentLoad("extrafont") # Tools to using system TrueType fonts 
windowsFonts(Arial=windowsFont("TT Arial"))
silentLoad("Cairo") # Library for  high-quality output
silentLoad("rmarkdown") # Dynamic documents for R
silentLoad("xlsx") # Read, write, and format Excel files
silentLoad("ppcor") # Calculates partial and semi-partial (part) correlations along with p-value

citations <- function(includeURL = TRUE, includeRStudio = TRUE) {
    if(includeRStudio == TRUE) {
        ref.rstudio <- RStudio.Version()$citation
        if(includeURL == FALSE) {
            ref.rstudio$url = NULL;
        }
        print(ref.rstudio, style = 'text')
        cat('\n')
    }

    cit.list <- c('base', names(sessionInfo()$otherPkgs))
    for(i in 1:length(cit.list)) {
        ref <- citation(cit.list[i])
        if(includeURL == FALSE) {
            ref$url = NULL;
        }
        print(ref, style = 'text')
        cat('\n')
    }
}

# ++++++++++++++++++++++++++++
# flattenCorrMatrix
# Source: http://www.sthda.com/english/wiki/correlationmatrixaquickstartguidetoanalyzeformatandvisualizeacorrelationmatrixusingrsoftware
# ++++++++++++++++++++++++++++
# cormat : matrix of the correlation coefficients
# pmat : matrix of the correlation p-values
flattenCorrMatrix <- function(cormat, pmat, digits = 2) {
    ut <- upper.tri(cormat)
    data.frame(
        row = rownames(cormat)[row(cormat)[ut]],
        column = rownames(cormat)[col(cormat)[ut]],
        cor = formatC((cormat)[ut], format = "f", digits),
        p = formatC((pmat[ut]), format = "E", digits)
    )
}

# Indices standardization. Centers it around its minimum if it is a
# positive index, around its maximum otherwise. Scales to its range in
# any case.
IndicStand <- function(Indic, negative = FALSE) {
  if (negative) {
    center <- max(Indic, na.rm = TRUE)
    scale <-
      min(Indic, na.rm = TRUE) - max(Indic, na.rm = TRUE)
  } else {
    center <- min(Indic, na.rm = TRUE)
    scale <-
      max(Indic, na.rm = TRUE) - min(Indic, na.rm = TRUE)
  }
  (Indic - center) / scale
}

```

## Composition of the IBEU index

Five dimensions (D1 - D5), each composed of one to seven indices
D1: Urban Mobility:
1. Home-to-Work Displacement
D2: Urban Environmental Conditions:
2. Arborization around households
3. Open sewage in the vicinity of households
4. Accumulated garbage around households
D3: Urban Housing Conditions:
5. Subnormal clump
6. Household density: number of people in the household per number of dormitories
7. Resident / Bathroom Density 
8. Household wall material
9. Species of households
D4: Attendance of Urban Collective Services:
10. Water supply
11. Sewage treatment
12. Electricity supply
13. Waste collection
D5: Urban Infrastructure:
14. Public lighting
15. Paving
16. Sidewalk
17. Curb / Guide
18. Road gully
19. Wheelchair ramp
20. Street address identification

Polygons of Brazilian States and Municipalities. Retrieved from: http://www.gmapas.com/poligonos-ibge/municipios-do-brasil

```{r Polygons, echo = FALSE}
# Polygons of Brazilian States and Municipalities
municipiosFile <- "data/municipios.kml"
layersList <- rgdal::ogrListLayers(municipiosFile)
municipios <- rgdal::readOGR(
    municipiosFile,
    layer = layersList[1],
    stringsAsFactors = FALSE,
    encoding = "UTF-8", 
    use_iconv = TRUE
)
# Transform to a data frame for ggplot2 graphics facility
municipiosDF <- broom::tidy(municipios)

## Order matters for geom_path!
municipiosDF <- municipiosDF[order(municipiosDF$order),]

# Extract list of ID's and municipalities names
IDlist <- data.frame(
        id = sapply(municipios@polygons, function(x) slot(x, 'ID')),
        nome = municipios@data$Name,
        stringsAsFactors = FALSE
)
keepList <- IDlist$id[IDlist$nome != ""]
IDlist <- subset(IDlist, (id %in% keepList))
municipiosDF <- subset(municipiosDF, (id %in% keepList))
```

Table of Centroids' municipalities locations. Retrieved from:
https://github.com/kelvins/Municipios-Brasileiros/tree/master/csv

```{r centroids}
# Centroids' municipalities locations
centroidsFile <- "data/municipios-centroids.csv"
# Read only relevant variables
centroidsDF <- read_csv(
  centroidsFile,
  col_names = TRUE,
  cols_only(codigo_ibge = col_integer(),
            nome = col_character(),
            latitude = col_number(),
            longitude = col_number()
  ),
  locale(encoding = "Latin1")
)
centroidsDF <-
  plyr::rename(centroidsDF, c("codigo_ibge" = "CodMunicipio"))
centroidsDF <-
  plyr::rename(centroidsDF, c("nome" = "Nome_Municipio"))
centroidsDF <- plyr::rename(centroidsDF, c("latitude" = "lat"))
centroidsDF <- plyr::rename(centroidsDF, c("longitude" = "long"))
centroidsDF <- subset(centroidsDF, !duplicated(centroidsDF$CodMunicipio))
centroidsDF <- centroidsDF[order(centroidsDF$CodMunicipio),]

```

Table of Codes of Municipalities. Retrieved from: http://concla.ibge.gov.br/classificacoes/por-tema/codigo-de-areas/codigo-de-areas.html

```{r geocodigos}
# Geocodes from IBGE
codigosFile <- "data/municipios-codes.csv"
# Read only relevant variables
codigosDF <- read_csv(
    codigosFile,
    col_names = TRUE,
    cols_only(UF = col_character(),
              Municipio = col_character(),
              Nome_Municipio = col_character()),
    locale(encoding = "UTF-8")
)
codigosDF$CodMunicipio <- as.numeric(paste0(codigosDF$UF, codigosDF$Municipio))
codigosDF <- subset(codigosDF, !duplicated(codigosDF$CodMunicipio))
codigosDF <- codigosDF[order(codigosDF$CodMunicipio),]
codigosDF <- plyr::rename(codigosDF, c("Nome_Municipio" = "nome"))
codigosDF$UF <- NULL
codigosDF$Municipio <- NULL

IDlist$CodMunicipio <- codigosDF$CodMunicipio
```

IDEB 2011 data obtained from http://portal.inep.gov.br/web/portal-ideb/planilhas-para-download

```{r IDEB}

library(readr)

# Estatistics from IDEB 2011
IDEBDF <- as.data.frame(read_csv(
    "data/IDEB2011.csv",
    col_names = TRUE, 
    na = c("-"),
    cols_only(
        Codigo = col_integer(),
        IDEB = col_number()
    )
))
IDEBDF <- plyr::rename(IDEBDF, c('Codigo' = 'CodMunicipio'))

# Average over municipality
IDEBDF <- aggregate(IDEB ~ CodMunicipio,
                    data = IDEBDF, 
                    FUN = mean)
```

ENEM data obtained from 
http://portal.inep.gov.br/web/guest/microdados

```{r ENEM, echo = FALSE}
# File layout
CensoFileLayout <- as.data.frame(matrix(
    data = c(
        c("NU_ANO_CENSO", "NULL"),
        c("ID_TURMA", "NULL"),
        c("NO_TURMA", "NULL"),
        c("TX_HR_INICIAL", "NULL"),
        c("TX_MI_INICIAL", "NULL"),
        c("NU_DURACAO_TURMA", "NULL"),
        c("NU_MATRICULAS", "NULL"),
        c("TP_MEDIACAO_DIDATICO_PEDAGO", "NULL"),
        c("IN_ESPECIAL_EXCLUSIVA", "numeric"),
        c("IN_REGULAR", "numeric"),
        c("IN_EJA", "NULL"),
        c("IN_PROFISSIONALIZANTE", "NULL"),
        c("EtapaEnsino", "numeric"),
        c("CO_CURSO_EDUC_PROFISSIONAL", "NULL"),
        c("TP_TIPO_TURMA", "NULL"),
        c("IN_MAIS_EDUCACAO", "NULL"),
        c("NU_DIAS_ATIVIDADE", "NULL"),
        c("IN_DIA_SEMANA_DOMINGO", "NULL"),
        c("IN_DIA_SEMANA_SEGUNDA", "NULL"),
        c("IN_DIA_SEMANA_TERCA", "NULL"),
        c("IN_DIA_SEMANA_QUARTA", "NULL"),
        c("IN_DIA_SEMANA_QUINTA", "NULL"),
        c("IN_DIA_SEMANA_SEXTA", "NULL"),
        c("IN_DIA_SEMANA_SABADO", "NULL"),
        c("CO_TIPO_ATIVIDADE_1", "NULL"),
        c("CO_TIPO_ATIVIDADE_2", "NULL"),
        c("CO_TIPO_ATIVIDADE_3", "NULL"),
        c("CO_TIPO_ATIVIDADE_4", "NULL"),
        c("CO_TIPO_ATIVIDADE_5", "NULL"),
        c("CO_TIPO_ATIVIDADE_6", "NULL"),
        c("IN_BRAILLE", "NULL"),
        c("IN_RECURSOS_BAIXA_VISAO", "NULL"),
        c("IN_PROCESSOS_MENTAIS", "NULL"),
        c("IN_ORIENTACAO_MOBILIDADE", "NULL"),
        c("IN_SINAIS", "NULL"),
        c("IN_COMUNICACAO_ALT_AUMENT", "NULL"),
        c("IN_ENRIQ_CURRICULAR", "NULL"),
        c("IN_SOROBAN", "NULL"),
        c("IN_INFORMATICA_ACESSIVEL", "NULL"),
        c("IN_PORT_ESCRITA", "NULL"),
        c("IN_AUTONOMIA_ESCOLAR", "NULL"),
        c("IN_DISC_QUIMICA", "NULL"),
        c("IN_DISC_FISICA", "NULL"),
        c("IN_DISC_MATEMATICA", "NULL"),
        c("IN_DISC_BIOLOGIA", "NULL"),
        c("IN_DISC_CIENCIAS", "NULL"),
        c("IN_DISC_LINGUA_PORTUGUESA", "NULL"),
        c("IN_DISC_LINGUA_INGLES", "NULL"),
        c("IN_DISC_LINGUA_ESPANHOL", "NULL"),
        c("IN_DISC_LINGUA_FRANCES", "NULL"),
        c("IN_DISC_LINGUA_INDIGENA", "NULL"),
        c("IN_DISC_LINGUA_OUTRA", "NULL"),
        c("IN_DISC_ARTES", "NULL"),
        c("IN_DISC_EDUCACAO_FISICA", "NULL"),
        c("IN_DISC_HISTORIA", "NULL"),
        c("IN_DISC_GEOGRAFIA", "NULL"),
        c("IN_DISC_FILOSOFIA", "NULL"),
        c("IN_DISC_ENSINO_RELIGIOSO", "NULL"),
        c("IN_DISC_ESTUDOS_SOCIAIS", "NULL"),
        c("IN_DISC_SOCIOLOGIA", "NULL"),
        c("IN_DISC_EST_SOCIAIS_SOCIOLOGIA", "NULL"),
        c("IN_DISC_INFORMATICA_COMPUTACAO", "NULL"),
        c("IN_DISC_PROFISSIONALIZANTE", "NULL"),
        c("IN_DISC_ATENDIMENTO_ESPECIAIS", "NULL"),
        c("IN_DISC_DIVER_SOCIO_CULTURAL", "NULL"),
        c("IN_DISC_LIBRAS", "NULL"),
        c("IN_DISC_PEDAGOGICAS", "NULL"),
        c("IN_DISC_OUTRAS", "NULL"),
        c("CodEntidade", "numeric"),
        c("CO_REGIAO", "NULL"),
        c("CO_MESORREGIAO", "NULL"),
        c("CO_MICRORREGIAO", "NULL"),
        c("CO_UF", "NULL"),
        c("CodMunicipio", "numeric"),
        c("CO_DISTRITO", "NULL"),
        c("TP_DEPENDENCIA", "NULL"),
        c("TP_LOCALIZACAO", "NULL"),
        c("TP_CATEGORIA_ESCOLA_PRIVADA", "NULL"),
        c("IN_CONVENIADA_PP", "NULL"),
        c("TP_CONVENIO_PODER_PUBLICO", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_EMP", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_ONG", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIND", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_SIST_S", "NULL"),
        c("IN_MANT_ESCOLA_PRIVADA_S_FINS", "NULL"),
        c("TP_REGULAMENTACAO", "NULL"),
        c("TP_LOCALIZACAO_DIFERENCIADA", "NULL"),
        c("IN_EDUCACAO_INDIGENA", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(CensoFileLayout) <- c('Fieldname', 'ColType')

ENEMFileLayout <- as.data.frame(matrix(
    data = c(
        c("CodEntidade", "numeric"),
        c("NomeEntidade", "NULL"),
        c("UF", "NULL"),
        c("Munic", "NULL"),
        c("Admin", "NULL"),
        c("Local", "NULL"),
        c("NumAlunos", "numeric"),
        c("Porte", "NULL"),
        c("PartENEM", "NULL"),
        c("TaxPart", "NULL"),
        c("PartNE", "NULL"),
        c("Perm", "NULL"),
        c("SocioEcon", "character"),
        c("FFormDoc", "NULL"),
        c("FormDoc", "NULL"),
        c("Aprov", "NULL"),
        c("Reprov", "NULL"),
        c("Aband", "NULL"),
        c("Top30", "NULL"),
        c("Media", "numeric"),
        c("Nivel1", "NULL"),
        c("Nivel2", "NULL"),
        c("Nivel3", "NULL"),
        c("Nivel4", "NULL"),
        c("Nivel5", "NULL")
    ),
    ncol = 2,
    byrow = TRUE
), stringsAsFactors = FALSE)
colnames(ENEMFileLayout) <- c('Fieldname', 'ColType')

readDataFile <-
        function(filename,
                 header,
                 sep,
                 FileLayout,
                 skip,
                 nrows,
                 comment.char
                 ) {
                # Read datafile
                if (!file.exists(paste0("data/", filename)))
                        stop(paste("File", filename, "not found!"))
                readData <- read.table(
                        file = paste0("data/", filename),
                        header = header,
                        sep = sep,
                        colClasses = FileLayout$ColType,
                        skip = skip,
                        nrows = nrows,
                        comment.char = comment.char,
                        stringsAsFactors = FALSE,
                        quote=""
                )
                if (nrow(readData) == 0) {
                        stop(paste("Empty file", filename, "!"))
                } else {
                        print(paste(nrow(readData), "lines read."))
                }
                colnames(readData) <- FileLayout$Fieldname[which(FileLayout$ColType != "NULL")]
                readData
        }

CensoData <- 
        readDataFile( 
                filename = "TURMAS.CSV",
                header = TRUE,
                sep = "|",
                FileLayout = CensoFileLayout,
                skip = 0,
                nrows = 3000000,
                comment.char = ""
        )

CensoData <- subset(CensoData, IN_REGULAR == 1 & IN_ESPECIAL_EXCLUSIVA == 0)
CensoData$IN_ESPECIAL_EXCLUSIVA <- NULL
CensoData$IN_REGULAR <- NULL
EnsMedio <- c(25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 64, 67, 71, 74)
CensoData <- subset(CensoData, EtapaEnsino %in% EnsMedio)
CensoData$EtapaEnsino <- NULL
CensoData <- unique(CensoData)
CensoData <- CensoData[!duplicated(CensoData$CodEntidade), ]

ENEMData <- 
        readDataFile(
                filename = "ENEM2015_CHumanas.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
ENEMData <- plyr::rename(ENEMData, c("Media" = "CHumanas"))

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_CNatureza.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- plyr::rename(NewENEMData, c('Media' = 'CNatureza'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'CNatureza')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Linguagens.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- plyr::rename(NewENEMData, c('Media' = 'Linguagens'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Linguagens')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Redacao.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- plyr::rename(NewENEMData, c('Media' = 'Redacao'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Redacao')], by = 'CodEntidade')

NewENEMData <- 
        readDataFile(
                filename = "ENEM2015_Matematica.csv",
                header = TRUE,
                sep = ";",
                FileLayout = ENEMFileLayout,
                skip = 0,
                nrows = 16000,
                comment.char = ""
        )
NewENEMData <- plyr::rename(NewENEMData, c('Media' = 'Matematica'))
ENEMData <- merge(ENEMData, NewENEMData[,c('CodEntidade', 'Matematica')], by = 'CodEntidade')

ENEMData <- subset(ENEMData, SocioEcon != "Sem informa??o") 

ENEMDF <- merge(CensoData, ENEMData, by = 'CodEntidade', all = FALSE)

# Tansformations
ENEMDF$SocioEcon <-
        factor(
                ENEMDF$SocioEcon,
                levels = c(
                        "Muito Baixo",
                        "Baixo",
                        "M?dio Baixo",
                        "M?dio",
                        "M?dio Alto",
                        "Alto",
                        "Muito alto"
                ),
                ordered = TRUE
        )

ENEMDF$CHumanas <- ENEMDF$CHumanas * ENEMDF$NumAlunos
ENEMDF$CNatureza <- ENEMDF$CNatureza * ENEMDF$NumAlunos
ENEMDF$Linguagens <- ENEMDF$Linguagens * ENEMDF$NumAlunos
ENEMDF$Redacao <- ENEMDF$Redacao * ENEMDF$NumAlunos
ENEMDF$Matematica <- ENEMDF$Matematica * ENEMDF$NumAlunos
ENEMDF$SocioEcon <- as.numeric(ENEMDF$SocioEcon) * ENEMDF$NumAlunos

ENEMDF <-
        aggregate(
                cbind(
                        NumAlunos,
                        SocioEcon,
                        CHumanas,
                        CNatureza,
                        Linguagens,
                        Redacao,
                        Matematica
                ) ~ CodMunicipio,
                data = ENEMDF,
                FUN = sum,
                na.action = na.omit
        )

ENEMDF$SocioEcon <- ENEMDF$SocioEcon / ENEMDF$NumAlunos
ENEMDF$CHumanas <- ENEMDF$CHumanas / ENEMDF$NumAlunos
ENEMDF$CNatureza <- ENEMDF$CNatureza / ENEMDF$NumAlunos
ENEMDF$Linguagens <- ENEMDF$Linguagens / ENEMDF$NumAlunos
ENEMDF$Redacao <- ENEMDF$Redacao / ENEMDF$NumAlunos
ENEMDF$Matematica <- ENEMDF$Matematica / ENEMDF$NumAlunos

ENEMDF$NumAlunos <- NULL

ENEMDF$ENEM <- rowMeans(ENEMDF[,c('CHumanas', 'CNatureza', 'Linguagens', 'Redacao', 'Matematica')], na.rm = TRUE)
ENEMDF <- subset(ENEMDF, select = c('CodMunicipio', 'ENEM', 'SocioEcon'))
```

```{r IBEU, echo = FALSE}
# Read only relevant variables
# Read the data from the .xlsx file.

# The commute-to-work indicator is built on the commute time that employed persons who work out of the home and return home daily use on the commute between home and place of work. It is considered as adequate commuting time when people spend up to 1 hour a day commuting. Thus, the proportion of employed persons who work away from home and return home daily who spend up to 1 hour on the commute is used.

tempo_deslocDF <- as.data.frame(read_csv(
    "data/01_tempo_deslocamento.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
tempo_deslocDF <-
        plyr::rename(tempo_deslocDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'TDeslocamento'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
tempo_deslocDF$TDeslocamento <-
        IndicStand(tempo_deslocDF$TDeslocamento, negative = FALSE)

# However, for this work, we also calculated an average travel time for each municipality.
tempo_desloc2DF <- as.data.frame(read_csv(
    "data/tempo_deslocamento2.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
tempo_desloc2DF <-
        plyr::rename(tempo_desloc2DF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'TMDeslocamento'))

# The indicator of forestation around households is obtained from the proportion of people living in households whose environment has forestation.
arborizacaoDF <- as.data.frame(read_csv(
    "data/02_arborizacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
arborizacaoDF <-
        plyr::rename(arborizacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Arborizacao'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
arborizacaoDF$Arborizacao <-
        IndicStand(arborizacaoDF$Arborizacao, negative = FALSE)

# The indicator of open sewage in the surroundings of the houses is constructed from the proportion of people living in households that do not have open sewage in their surroundings.
esgoto_abertoDF <- as.data.frame(read_csv(
    "data/03_esgoto_ceu_aberto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
esgoto_abertoDF <-
        plyr::rename(esgoto_abertoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EsgCeuAberto'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
esgoto_abertoDF$EsgCeuAberto <-
        IndicStand(esgoto_abertoDF$EsgCeuAberto, negative = FALSE)

# The indicator of accumulated garbage in the surroundings of the households is obtained from the proportion of people living in households that do not have accumulated garbage in their surroundings.
lixo_acumDF <- as.data.frame(read_csv(
    "data/04_lixo_acumulado.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
lixo_acumDF <-
        plyr::rename(lixo_acumDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'LixoAcumulado'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
lixo_acumDF$LixoAcumulado <-
        IndicStand(lixo_acumDF$LixoAcumulado, negative = FALSE)

# The subnormal clump indicator corresponds to the proportion of people from the weighting area who do not live in subnormal clumps.
aglom_subnormDF <- as.data.frame(read_csv(
    "data/05_aglomerado_subnormal.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
aglom_subnormDF <-
        plyr::rename(aglom_subnormDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AglomSubnormal'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
aglom_subnormDF$AglomSubnormal <-
        IndicStand(aglom_subnormDF$AglomSubnormal, negative = FALSE)

# The household density indicator is constructed from the ratio between the number of people in the household and the number of dormitories. It was considered adequate household density when there were up to 2 people per dormitory. The household density indicator was considered as the proportion of people who are in households whose density is up to 2 people per dormitory. Obs: In this work, instead, the average number of people per dormitory per municipality, calculated by the product of the totals of households by the categories of people per dormitory, '1', '2', '3', '4 ', divided by the total number of households in each municipality..
dens_domicilDF <- as.data.frame(read_csv(
    "data/06_densidade_domiciliar.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_domicilDF <-
        plyr::rename(dens_domicilDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'DensDomiciliar'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
dens_domicilDF$DensDomiciliar <-
        IndicStand(dens_domicilDF$DensDomiciliar, negative = FALSE)

# The household density indicator is constructed from the ratio between the number of people in the household and the number of dormitories. It was considered adequate household density when there were up to 2 people per dormitory. The household density indicator was considered as the proportion of people who are in households whose density is up to 2 people per dormitory. Obs: In this work, instead, the average number of people per dormitory per municipality, calculated by the product of the totals of households by the categories of people per dormitory, '1', '2', '3', '4 ', divided by the total number of households in each municipality.
dens_mor_banhDF <- as.data.frame(read_csv(
    "data/07_densidade_morador-banheiro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
dens_mor_banhDF <-
        plyr::rename(dens_mor_banhDF,
               c('Codigo' = 'CodMunicipio', 
                 'Indice' = 'DensMoradBanheiro'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
dens_mor_banhDF$DensMoradBanheiro <-
        IndicStand(dens_mor_banhDF$DensMoradBanheiro, negative = FALSE)

# In the indicator of adequacy of household wall material, it was considered as suitable the domicile whose external walls are of the type of masonry with coating or wood suitable for construction (equipped). In this case, the indicator of dequacy of household wall material corresponds to the proportion of people who are in homes with adequate wall material.
material_paredesDF <- as.data.frame(read_csv(
    "data/08_material_paredes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
material_paredesDF <-
        plyr::rename(material_paredesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MaterialParedes'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
material_paredesDF$MaterialParedes <-
        IndicStand(material_paredesDF$MaterialParedes, negative = FALSE)

# In the indicator of type of households, it was considered as adequate the households of the type house, village house, condominium or apartment and inadequate the dwellings of the type rooming house, slum,  tenement-houses, tent, and others (wagons, trailers, grottos, etc.). In this case, the household species indicator corresponds to the proportion of people who live in households of adequate species.
especie_domiciliosDF <- as.data.frame(read_csv(
    "data/09_especie_domicilios.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
especie_domiciliosDF <-
        plyr::rename(especie_domiciliosDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'EspecDomicilio'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
especie_domiciliosDF$EspecDomicilio <-
        IndicStand(especie_domiciliosDF$EspecDomicilio, negative = FALSE)

# Water service is considered adequate when it is done by general water network. The water supply indicator corresponds to the proportion of people living in homes with adequate water supply.
atendimento_aguaDF <- as.data.frame(read_csv(
    "data/10_atendimento_agua.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_aguaDF <-
        plyr::rename(atendimento_aguaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoAgua'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_aguaDF$AtendimentoAgua <-
        IndicStand(atendimento_aguaDF$AtendimentoAgua, negative = FALSE)

# Sewage service is considered adequate when it is done by general sewage network. The indicator of sewage service corresponds to the proportion of people who live in the home with adequate sewage service.
atendimento_esgotoDF <- as.data.frame(read_csv(
    "data/11_atendimento_esgoto.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_esgotoDF <-
        plyr::rename(atendimento_esgotoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEsgoto'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_esgotoDF$AtendimentoEsgoto <-
        IndicStand(atendimento_esgotoDF$AtendimentoEsgoto, negative = FALSE)

# Energy service is considered adequate when there is electricity from distribution companies or other sources, and being from a distributor company when there is a meter. The indicator of energy attendance corresponds to the proportion of people who live at home with adequate energy attendance.
atendimento_energiaDF <- as.data.frame(read_csv(
    "data/12_atendimento_energia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
atendimento_energiaDF <-
        plyr::rename(atendimento_energiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'AtendimentoEnergia'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
atendimento_energiaDF$AtendimentoEnergia <-
        IndicStand(atendimento_energiaDF$AtendimentoEnergia, negative = FALSE)

# Waste collection is considered adequate when waste is collected directly by cleaning service or when placed in a bucket for cleaning service. The indicator of waste collection corresponds to the proportion of people who live in the household with adequate waste collection..
coleta_lixoDF <- as.data.frame(read_csv(
    "data/13_coleta_lixo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
coleta_lixoDF <-
        plyr::rename(coleta_lixoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'ColetaLixo'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
coleta_lixoDF$ColetaLixo <-
        IndicStand(coleta_lixoDF$ColetaLixo, negative = FALSE)

# The public lighting indicator corresponds to the proportion of people living in households whose surroundings have public lighting. 
iluminacao_publicaDF <- as.data.frame(read_csv(
    "data/14_iluminacao_publica.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
iluminacao_publicaDF <-
        plyr::rename(iluminacao_publicaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IluminacaoPublica'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
iluminacao_publicaDF$IluminacaoPublica <-
        IndicStand(iluminacao_publicaDF$IluminacaoPublica, negative = FALSE)

# The paving indicator corresponds to the proportion of people living at homes whose street has pavement (asphalt, concrete, stones, etc.).
pavimentacaoDF <- as.data.frame(read_csv(
    "data/15_pavimentacao.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
pavimentacaoDF <-
        plyr::rename(pavimentacaoDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Pavimentacao'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
pavimentacaoDF$Pavimentacao <-
        IndicStand(pavimentacaoDF$Pavimentacao, negative = FALSE)

# The sidewalk indicator corresponds to the proportion of people living at homes whose face to the street is located has a sidewalk.
calcadaDF <- as.data.frame(read_csv(
    "data/16_calcada.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
calcadaDF <-
        plyr::rename(calcadaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'Calcada'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
calcadaDF$Calcada <- IndicStand(calcadaDF$Calcada, negative = FALSE)

# The curb/guide indicator corresponds to the proportion of people living at homes whose face to the street is located has a curb/guide.
meiofio_guiaDF <- as.data.frame(read_csv(
    "data/17_meio-fio_guia.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
meiofio_guiaDF <-
        plyr::rename(meiofio_guiaDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'MeiofioGuia'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
meiofio_guiaDF$MeiofioGuia <-
        IndicStand(meiofio_guiaDF$MeiofioGuia, negative = FALSE)

# The indicator of road gully corresponds to the proportion of people living in households whose environment has road gullies. The identification of road gullies in the surroundings of the domiciles corresponds to the confronting face face to the street where the domicile is located.
bueiro_boca_de_loboDF <- as.data.frame(read_csv(
    "data/18_bueiro_boca_de_lobo.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
bueiro_boca_de_loboDF <-
        plyr::rename(bueiro_boca_de_loboDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'BueiroBocadelobo'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
bueiro_boca_de_loboDF$BueiroBocadelobo <-
        IndicStand(bueiro_boca_de_loboDF$BueiroBocadelobo, negative = FALSE)

# The wheelchair ramp indicator corresponds to the proportion of people living at homes whose face of the street where the home is located has a ramp to give access to people who use wheelchairs.
rampa_cadeirantesDF <- as.data.frame(read_csv(
    "data/19_rampa_cadeirantes.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
rampa_cadeirantesDF <-
        plyr::rename(rampa_cadeirantesDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'RampaCadeirantes'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
rampa_cadeirantesDF$RampaCadeirantes <-
        IndicStand(rampa_cadeirantesDF$RampaCadeirantes, negative = FALSE)

# The address identification indicator corresponds to the proportion of people living at home where the street has identification.
ident_logradouroDF <- as.data.frame(read_csv(
    "data/20_identificacao_logradouro.csv",
    col_names = TRUE, 
    cols_only(
        Codigo = col_integer(),
        Indice = col_number()
    ),
    locale(encoding = "UTF-8")
))
ident_logradouroDF <-
        plyr::rename(ident_logradouroDF,
               c('Codigo' = 'CodMunicipio', 'Indice' = 'IdentLogradouro'))
# For the standardization of the index, it was considered that this is a positive index, since higher welfare corresponds to higher index values
ident_logradouroDF$IdentLogradouro <-
        IndicStand(ident_logradouroDF$IdentLogradouro, negative = FALSE)
```

```{r IndicatorsData, echo = FALSE}
# All the indices are merged into one single database
IndicatorsData <- merge(
        IDEBDF,
        ENEMDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
IndicatorsData$SocioEcon <-
  scales::rescale(IndicatorsData$SocioEcon,
                  from = c(1, 7),
                  to = c(0, 1))
IndicatorsData <- merge(
        IndicatorsData,
        tempo_desloc2DF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        tempo_deslocDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        arborizacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        esgoto_abertoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        lixo_acumDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
# As the 'Aglomerado subnormal' indicator was evaluated on the metropolis only, it has entries 322 only and missing values are missing entries are filled with the median of the set of values
IndicatorsData <- merge(
        IndicatorsData,
        aglom_subnormDF,
        by = 'CodMunicipio',
        all = TRUE,
        incomparables = NA
)
medianValue <- median(aglom_subnormDF$AglomSubnormal)
IndicatorsData$AglomSubnormal <-
    ifelse(is.na(IndicatorsData$AglomSubnormal),
           medianValue,
           IndicatorsData$AglomSubnormal)
IndicatorsData <- merge(
        IndicatorsData,
        dens_domicilDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        dens_mor_banhDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        material_paredesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        especie_domiciliosDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_aguaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_esgotoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        atendimento_energiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        coleta_lixoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        iluminacao_publicaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        pavimentacaoDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        calcadaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        meiofio_guiaDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        bueiro_boca_de_loboDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        rampa_cadeirantesDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
IndicatorsData <- merge(
        IndicatorsData,
        ident_logradouroDF,
        by = 'CodMunicipio',
        all = FALSE,
        incomparables = NA
)
# Duplicate entries are eliminated
IndicatorsData <-
        subset(IndicatorsData, !duplicated(IndicatorsData$CodMunicipio))
```

```{r IndicsComparData, echo = FALSE}

IndicsComparData <- subset(IndicatorsData, select = -CodMunicipio)

IndicsCorrMtx <- Hmisc::rcorr(as.matrix(IndicsComparData))

IndicsComparData <-
  IndicsComparData[, c(names(IndicsComparData['IDEB']),
                       names(sort(abs(IndicsCorrMtx$r[1,-1]),
                                  decreasing = TRUE)))]
IndicsCorrMtx <- Hmisc::rcorr(as.matrix(IndicsComparData))

```

```{r Table4}

Table4 <- data.frame(
  var = character(),
  r = numeric(),
  p = numeric(),
  pr = numeric(),
  pp = numeric(),
  spr = numeric(),
  spp = numeric(),
  stringsAsFactors = FALSE
)

varset <- colnames(IndicatorsData)
varset <- varset[!(varset %in% c('CodMunicipio', 'IDEB', 'SocioEcon', 'TMDeslocamento'))]

for(var in varset) {
  
  data <- subset(IndicatorsData,
                 select = c('IDEB',
                            var,
                            'SocioEcon'))
  data <- na.exclude(data)
  
  results <- stats::cor.test(x = data$IDEB,
                             y = data[, var],
                             method = "pearson")
  
  r <- results$estimate
  p <- results$p.value
  
  results <- ppcor::pcor.test(x = data$IDEB,
                              y = data[, var],
                              z = data$SocioEcon,
                              method = "pearson")
  pr <- results$estimate
  pp <- results$p.value
  
  results <- ppcor::spcor.test(x = data$IDEB,
                              y = data[, var],
                              z = data$SocioEcon,
                              method = "pearson")
  spr <- results$estimate
  spp <- results$p.value
  
  Table4 <- rbind(
    Table4,
    data.frame(
      var = var,
      r = r,
      p = p,
      pr = pr,
      pp = pp,
      spr = spr,
      spp = spp,
      stringsAsFactors = FALSE
    )
  )
}

Table4$r[Table4$p > 0.05] <- NA
Table4$pr[Table4$pp > 0.05] <- NA
Table4$spr[Table4$spp > 0.05] <- NA

Table4 <- Table4[order(Table4$pr,
                       decreasing = TRUE), ]

xlsx::write.xlsx(
  data.frame(
    var = Table4$var,
    r = formatC(Table4$r, 
                format = "f", 2),
    p = formatC(Table4$p, 
                format = "E", 1),
    pr = formatC(Table4$pr, 
                format = "f", 2),
    pp = formatC(Table4$pp, 
                format = "E", 1),
    spr = formatC(Table4$spr, 
                format = "f", 2),
    spp = formatC(Table4$spp, 
                format = "E", 1),
    stringsAsFactors = FALSE
  ),
  file = "data/Table4.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r IndicsPCorrTable2}

IndicsPCorrTable2 <- data.frame(
  var = character(),
  pr = numeric(),
  p = numeric()
)

varset <- colnames(IndicatorsData)
varset <- varset[!(varset %in% c('CodMunicipio', 'IDEB', 'SocioEcon', 'ENEM', 'TMDeslocamento'))]


for(var in varset) {
  
  data <- subset(IndicatorsData,
                 select = c('IDEB',
                            var,
                            'SocioEcon'))
  data <- na.exclude(data)
  
  results <- ppcor::pcor.test(x = data$IDEB,
                              y = data[, var],
                              z = data$SocioEcon,
                              method = "pearson")
  
  IndicsPCorrTable2 <- rbind(
    IndicsPCorrTable2,
    data.frame(
      var = var,
      pr = results$estimate,
      p = results$p.value
    )
  )
}

IndicsPCorrTable2$pr[IndicsPCorrTable2$p > 0.05] <- NA

xlsx::write.xlsx(
  data.frame(
    var = IndicsPCorrTable$var,
    pr = formatC(IndicsPCorrTable2$pr, 
                format = "f", 2),
    p = formatC(IndicsPCorrTable2$p, 
                format = "E", 2)
  ),
  file = "data/IndicsPCorrTable2.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r Table3, echo = FALSE}

library(dplyr)

SocEconComparData <-
  dplyr::select(IndicsComparData, SocioEcon,
                everything())

results <- Hmisc::rcorr(as.matrix(SocEconComparData))

Table3 <- 
  data.frame(
    var = names(results$r[1,-1]),
    r = unname(results$r[1,-1]),
    p = unname(results$P[1,-1]),
    stringsAsFactors = FALSE
    )

Table3$r[Table3$p > 0.05] <- NA 

Table3 <- Table3[order(Table3$r, decreasing = TRUE), ]

xlsx::write.xlsx(
  data.frame(
    var = Table3$var,
    r = formatC(Table3$r, 
                format = "f", 2),
    p = formatC(Table3$p, 
                format = "E", 2)
  ),
  file = "data/Table3.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r DimensionsData, echo = FALSE}
DimensionsData <-
  data.frame(
    CodMunicipio = IndicatorsData$CodMunicipio,
    IDEB = IndicatorsData$IDEB,
    ENEM = IndicatorsData$ENEM,
    SE = IndicatorsData$SocioEcon,
    TMDeslocamento = IndicatorsData$TMDeslocamento
  )
DimensionsData$D1 <- IndicatorsData$TDeslocamento
DimensionsData$D2 <-
  (
    IndicatorsData$Arborizacao +
      IndicatorsData$EsgCeuAberto +
      IndicatorsData$LixoAcumulado
  ) / 3
DimensionsData$D3 <-
  (
    IndicatorsData$AglomSubnormal +
      IndicatorsData$DensDomiciliar +
      IndicatorsData$DensMoradBanheiro +
      IndicatorsData$MaterialParedes +
      IndicatorsData$EspecDomicilio
  ) / 5
DimensionsData$D4 <-
  (
    IndicatorsData$AtendimentoAgua +
      2 * IndicatorsData$AtendimentoEsgoto +
      IndicatorsData$ColetaLixo +
      IndicatorsData$AtendimentoEnergia
  ) / 5
DimensionsData$D5 <-
  (
    IndicatorsData$IluminacaoPublica +
      IndicatorsData$Pavimentacao +
      IndicatorsData$Calcada +
      IndicatorsData$MeiofioGuia +
      IndicatorsData$BueiroBocadelobo +
      IndicatorsData$RampaCadeirantes +
      IndicatorsData$IdentLogradouro
  ) / 7
```

```{r Table5, echo = FALSE}

Table5 <- data.frame(
  var = character(),
  r = numeric(),
  p = numeric(),
  pr = numeric(),
  pp = numeric(),
  spr = numeric(),
  spp = numeric(),
  stringsAsFactors = FALSE
)

for(var in c('D1', 'D2', 'D3', 'D4', 'D5')) {
  
  data <- subset(DimensionsData,
                 select = c('IDEB',
                            var,
                            'SE'))
  data <- na.exclude(data)
  
  results <- stats::cor.test(x = data$IDEB,
                             y = data[, var],
                             method = "pearson")
  
  r <- results$estimate
  p <- results$p.value
  
  results <- ppcor::pcor.test(x = data$IDEB,
                              y = data[, var],
                              z = data$SE,
                              method = "pearson")
  
  pr <- results$estimate
  pp <- results$p.value
  
  results <- ppcor::spcor.test(x = data$IDEB,
                              y = data[, var],
                              z = data$SE,
                              method = "pearson")
  
  spr <- results$estimate
  spp <- results$p.value
  
  Table5 <- rbind(
    Table5,
    data.frame(
      var = var,
      r = r,
      p = p,
      pr = pr,
      pp = pp,
      spr = spr,
      spp = spp,
      stringsAsFactors = FALSE
    )
  )
}

Table5$r[Table5$p > 0.05] <- NA
Table5$pr[Table5$pp > 0.05] <- NA
Table5$spr[Table5$spp > 0.05] <- NA

Table5 <- Table5[order(Table5$pr,
                                       decreasing = TRUE),]

xlsx::write.xlsx(
  data.frame(
    var = Table5$var,
    r = formatC(Table5$r, 
                format = "f", 2),
    p = formatC(Table5$p, 
                format = "E", 1),
    pr = formatC(Table5$pr, 
                format = "f", 2),
    pp = formatC(Table5$pp, 
                format = "E", 2),
    spr = formatC(Table5$spr, 
                format = "f", 2),
    spp = formatC(Table5$spp, 
                format = "E", 1),
    stringsAsFactors = FALSE

  ),
  file = "data/Table5.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r IBEUData, echo = FALSE}
IBEUData <-
  data.frame(
    CodMunicipio =
      IndicatorsData$CodMunicipio,
    IDEB = IndicatorsData$IDEB,
    ENEM = IndicatorsData$ENEM,
    SE = IndicatorsData$SocioEcon,
    TMDeslocamento =
      IndicatorsData$TMDeslocamento
  )
IBEUData$IBEU <-
    (DimensionsData$D1 + 
     DimensionsData$D2 + 
     DimensionsData$D3 + 
     DimensionsData$D4 + 
     DimensionsData$D5) / 5
```

```{r merging, echo = FALSE}

IndicatorsDF <- merge(IndicatorsData,
                      subset(IDlist, select = -nome),
                      by = 'CodMunicipio',
                      all.y = FALSE)
IndicatorsDF <-
  IndicatorsDF[!duplicated(IndicatorsDF$CodMunicipio),]

DimensionsDF <- merge(DimensionsData,
                      subset(IDlist, select = -nome),
                      by = 'CodMunicipio',
                      all.y = FALSE)
DimensionsDF <-
  DimensionsDF[!duplicated(DimensionsDF$CodMunicipio),]

IBEUDF <- merge(IBEUData,
                subset(IDlist, select = -nome),
                by = 'CodMunicipio',
                all.y = FALSE)
IBEUDF <- IBEUDF[!duplicated(IBEUDF$CodMunicipio), ]
IBEUDF <-
  subset(IBEUDF, 
         select = c('id', 'IDEB', 'IBEU', 'CodMunicipio'))

```

```{r choroplMaps}

library(ggplot2)
library(colorplaner)
library(mapproj)
library(grid)

scale_x_longitude <- function(xmin = -180,
                              xmax = 180,
                              step = 1,
                              ...) {
  xbreaks <- seq(xmin, xmax, step)
  xlabels <-
    unlist(lapply(xbreaks, function(x)
      ifelse(
        x < 0, parse(text = paste0(-x, "^o", "*W")),
        ifelse(x > 0, parse(text = paste0(x, "^o", "*E")),
               x)
      )))
  return(scale_x_continuous(
    "Longitude",
    breaks = xbreaks,
    labels = xlabels,
    expand = c(0, 0),
    ...
  ))
}
scale_y_latitude <- function(ymin = -90,
                             ymax = 90,
                             step = 0.5,
                             ...) {
  ybreaks <- seq(ymin, ymax, step)
  ylabels <-
    unlist(lapply(ybreaks, function(x)
      ifelse(
        x < 0, parse(text = paste0(-x, "^o", "*S")),
        ifelse(x > 0, parse(text = paste0(x, "^o", "*N")),
               x)
      )))
  return(scale_y_continuous(
    "Latitude",
    breaks = ybreaks,
    labels = ylabels,
    expand = c(0, 0),
    ...
  ))
}

choroplMap <-
  function(datafile,
           xvarname,
           yvarname,
           plotTitle) {

    choroMap <- ggplot()
    
    choroMap <- choroMap +
        ggtitle(plotTitle)

    choroMap <- choroMap + 
      geom_map(
        data = datafile,
        aes(
          map_id = id,
          fill = datafile[, xvarname],
          fill2 = datafile[, yvarname]
          ),
        map = municipiosDF,
        color = 'NA'
        ) 
    
    choroMap <-
      choroMap + scale_fill_colorplane(
        axis_title = xvarname,
        axis_title_y = "Indicator",
        na.color = "white",
        color_projection = "YUV",
        Y = 0.4
      )
    
    choroMap <- choroMap + 
      expand_limits(x = municipiosDF$long,
                    y = municipiosDF$lat)
    
    choroMap <- choroMap + coord_map()
    
    choroMap <-
      choroMap + scale_x_longitude(xmin = -80,
                                   xmax = -30,
                                   step = 10)
    choroMap <-
      choroMap + scale_y_latitude(ymin = -40,
                                  ymax = +10,
                                  step = 10)
    
    choroMap <- choroMap +
      theme(
        line = element_line(colour = "grey95"),
        plot.background = 
          element_rect(fill = "white",
                       colour = "white"),
        panel.background = 
          element_rect(fill = "white",
                       colour = "white"),
        panel.grid = 
          element_line(colour = "grey95"),
        plot.title = element_text(size = 8,
                                  face = "bold"),
        legend.position = "bottom",
        legend.key.size = unit(10, "points"),
        plot.margin = unit(c(1, 1, 1, 1), "lines")
      )
    
    choroMap <- choroMap + ggsn::scalebar(
      municipiosDF,
      x.min = -80,
      x.max = -30,
      y.min = -40,
      y.max = +10,
      dist = 500,
      dist_unit = "km",
      location = "bottomright",
      anchor = c(x = -37, y = -30),
      transform = TRUE,
      model = 'WGS84',
      st.size = 2, 
      border.size = 0.5
    )
    
    ggsn::north2(choroMap,
           scale = 0.15,
           x = 0.8,
           symbol = 3)
    
    choroMap
    
  }

plotComparativeChoro <-
  function(plotDataTL, xvarTL, yvarTL, ploTitleTL,
           plotDataTR, xvarTR, yvarTR, ploTitleTR,
           plotDataML, xvarML, yvarML, ploTitleML,
           plotDataMR, xvarMR, yvarMR, ploTitleMR,
           plotDataBL, xvarBL, yvarBL, ploTitleBL,
           plotDataBR, xvarBR, yvarBR, ploTitleBR,
           figfilename) {
    
  # Make choroplet maps
    pTL <- choroplMap(plotDataTL, xvarTL, yvarTL,
                      ploTitleTL)
    pTR <- choroplMap(plotDataTR, xvarTR, yvarTR,
                      ploTitleTR)
    pML <- choroplMap(plotDataML, xvarML, yvarML,
                      ploTitleML)
    pMR <- choroplMap(plotDataMR, xvarMR, yvarMR,
                      ploTitleMR)
    pBL <- choroplMap(plotDataBL, xvarBL, yvarBL,
                      ploTitleBL)
    pBR <- choroplMap(plotDataBR, xvarBR, yvarBR,
                      ploTitleBR)
    
    thisGraph <- 
      ggpubr::ggarrange(pTL, pTR, pML,
                        pMR, pBL, pBR,
                        ncol = 2,
                        nrow = 3,
                        common.legend = TRUE,
                        legend = "bottom"
                        )
  
  # Connects to 'png' device for saving plot as .png a file
  Cairo::CairoPNG(
    filename = paste0("images/", figfilename, ".", "png"),
    width = 3600,
    height = 6500,
    dpi = 600,
    bg = "white"
  )
  
  # Draws the final plot to device
  plot(thisGraph)
  
  # Closes connection to 'png' device
  dev.off()

}

```

```{r ChoroMaps}

plotComparativeChoro(DimensionsDF, 'IDEB', 'D1',
                     "IDEB vs. D1",
                     DimensionsDF, 'IDEB', 'D2',
                     "IDEB vs. D2",
                     DimensionsDF, 'IDEB', 'D3',
                     "IDEB vs. D3",
                     DimensionsDF, 'IDEB', 'D4',
                     "IDEB vs. D4",
                     DimensionsDF, 'IDEB', 'D5',
                     "IDEB vs. D5",
                     DimensionsDF, 'IDEB', 'SE',
                     "IDEB vs. SE",
                     "Figure4"
)

```

```{r ChoroMaps}

plotComparativeChoro(IndicatorsDF, 'IDEB',
                     'DensMoradBanheiro',
                     "IDEB vs. Resident/bathroom density",
                     IndicatorsDF, 'IDEB',
                     'MaterialParedes',
                     'IDEB vs. Household wall material',
                     IndicatorsDF, 'IDEB',
                     'Pavimentacao',
                     'IDEB vs. Paving',
                     IndicatorsDF, 'IDEB',
                     'MeiofioGuia',
                     'IDEB vs. Curb / Guide',
                     IndicatorsDF, 'IDEB',
                     'ColetaLixo',
                     'IDEB vs. Waste collection',
                     IndicatorsDF, 'IDEB',
                     'AtendimentoEnergia',
                     'IDEB vs. Electricity supply',
                     "Figure5")


```

```{r DataGini, echo = FALSE}

DataGini <- function(datafile, varname) {
  thisTable <-
    data.frame(
      Gini = numeric(),
      gw.frac = numeric(),
      ns.frac = numeric(),
      p = numeric(),
      Moran.I = numeric(),
      EI = numeric(),
      p.rsamp = numeric(),
      p.rand = numeric()
    )
  
  data <- na.exclude(datafile)
  data <-
    merge(centroidsDF,
          data, 
          by = "CodMunicipio")
  Bandwidth <- 12 #min(36, nrow(data) - 1)
  
  thisMoran <-
    lctools::moransI(
      Coords = cbind(data$lat, data$long),
      Bandwidth,
      x = data[ ,varname],
      WType = 'Binary'
    )
  
  thisGini <-
    lctools::spGini(
      Coords = cbind(data$lat, data$long),
      Bandwidth,
      x = data[ ,varname],
      WType = 'Binary'
    )
  
  thisMC <-
    lctools::mc.spGini(
      Nsim = 19,
      Bandwidth,
      x = data[ ,varname],
      Coord.X = data$lat,
      Coord.Y = data$long,
      WType = 'Binary'
    )
  
  thisTable <-
    data.frame(
      Gini = unname(thisGini["Gini"]),
      gw.frac = unname(thisGini["gwGini.frac"]),
      ns.frac = unname(thisGini["nsGini.frac"]),
      p = thisMC$pseudo.p,
      Moran.I = thisMoran$Morans.I,
      EI = thisMoran$Expected.I,
      z.res = thisMoran$z.resampling,
      z.rand = thisMoran$z.randomization,
      p.rsamp = thisMoran$p.value.resampling,
      p.rand = thisMoran$p.value.randomization
    )
  
  RPushbullet::pbPost(
    type = "note",
    title = paste('DataGini for', 
                  varname, 
                  "finished!"),
    apikey = "o.SYjKv7goGyRzOWif4k8hwA6wPw1Hg00q",
    devices = "Galaxy A8"
  )
  
  thisTable
  
}

```

```{r giniTables, echo = FALSE}

D1Gini <- DataGini(DimensionsDF, 'D1')
D2Gini <- DataGini(DimensionsDF, 'D2')
D3Gini <- DataGini(DimensionsDF, 'D3')
D4Gini <- DataGini(DimensionsDF, 'D4')
D5Gini <- DataGini(DimensionsDF, 'D5')
SEGini <- DataGini(DimensionsDF, 'SE')
IDEBGini <- DataGini(DimensionsDF, 'IDEB')
ENEMGini <- DataGini(DimensionsDF, 'ENEM')
IBEUGini <- DataGini(IBEUDF, 'IBEU')

GiniTable <-
  data.frame(
    Indic = c("D1", "D2", "D3", "D4", "D5", "SE", "IDEB", "ENEM", "IBEU"),
    stringsAsFactors = FALSE
  )
GiniTable <-
  cbind(GiniTable,
        rbind(D1Gini, D2Gini, D3Gini, D4Gini, D5Gini, SEGini, IDEBGini, ENEMGini, IBEUGini))

xlsx::write.xlsx(
  data.frame(
    Indic = GiniTable$Indic,
    Gini = formatC(GiniTable$Gini, format = "f", 2),
    gw.frac = formatC(GiniTable$gw.frac, format = "E", 1),
    ns.frac = formatC(GiniTable$ns.frac, format = "f", 3),
    p = formatC(GiniTable$p, format = "f", 2),
    EI = formatC(GiniTable$EI, format = "E", 1),
    z.res = formatC(GiniTable$z.res, format = "f", 2),
    z.rand = formatC(GiniTable$z.rand, format = "f", 2),
    p.rsamp = formatC(GiniTable$p.rsamp, format = "E", 1),
    formatC(GiniTable$p.rand, format = "E", 1)
  ),
  file = "data/Table2.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r ScatterPlots}

library(ggplot2)

scatterPlot <- function(datafile,
         xvarname, yvarname,
         xaxisTitle, plotTitle = NULL) {
  
  thisGraph <- ggplot(datafile,
                      aes_(as.name(xvarname),
                           as.name(yvarname))) +
    geom_point(
      colour = "blue",
      size = 0.5,
      alpha = 0.2,
      na.rm = TRUE
      ) +
    stat_ellipse(size = 0.2, na.rm = TRUE)
  
    thisGraph <- thisGraph + xlim(0, 1)
    
    if(!is.null(plotTitle)) {
      thisGraph <- thisGraph +
        ggtitle(plotTitle)
      }
    
    thisGraph <- thisGraph +
      xlab(xaxisTitle)
    
    thisGraph <- thisGraph + theme_bw() +
      theme(
        panel.border = element_blank(),
        panel.grid.major = 
          element_line(colour = "grey80"),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = 
          element_text(size = 11, face = "bold")
        )
  
  thisGraph
  
}

plotComparativeScat <-
  function(plotDataTL, xvarTL, yvarTL, xaxisTitleTL,
           plotDataTR, xvarTR, yvarTR, xaxisTitleTR,
           plotDataML, xvarML, yvarML, xaxisTitleML,
           plotDataMR, xvarMR, yvarMR, xaxisTitleMR,
           plotDataBL, xvarBL, yvarBL, xaxisTitleBL,
           plotDataBR, xvarBR, yvarBR, xaxisTitleBR,
           figfilename) {
    
  # Make scatter plots
    pTL <- scatterPlot(plotDataTL, xvarTL, yvarTL, xaxisTitleTL, plotTitle = 'A')
    pTR <- scatterPlot(plotDataTR, xvarTR, yvarTR, xaxisTitleTR, plotTitle = 'B')
    pML <- scatterPlot(plotDataML, xvarML, yvarML, xaxisTitleML, plotTitle = 'C')
    pMR <- scatterPlot(plotDataMR, xvarMR, yvarMR, xaxisTitleMR, plotTitle = 'D')
    pBL <- scatterPlot(plotDataBL, xvarBL, yvarBL, xaxisTitleBL, plotTitle = 'E')
    pBR <- scatterPlot(plotDataBR, xvarBR, yvarBR, xaxisTitleBR, plotTitle = 'F')
    
  thisGraph <- ggpubr::ggarrange(pTL, pTR, pML, pMR, pBL, pBR,
                       ncol = 2, nrow = 3
  )
  
  # Connects to 'png' device for saving plot as .png a file
  Cairo::CairoPNG(
    filename = paste0("images/", figfilename, ".", "png"),
    width = 3600,
    height = 3600,
    dpi = 600,
    bg = "white"
  )
  
  # Draws the final plot to device
  plot(thisGraph)
  
  # Closes connection to 'png' device
  dev.off()

}

```

```{r scatterPlots}

plotComparativeScat(DimensionsDF, 'D1', 'IDEB', 'D1',
                    DimensionsDF, 'D2', 'IDEB', 'D2',
                    DimensionsDF, 'D3', 'IDEB', 'D3',
                    DimensionsDF, 'D4', 'IDEB', 'D4',
                    DimensionsDF, 'D5', 'IDEB', 'D5',
                    DimensionsDF, 'SE', 'IDEB', 'SE',
                    'Figure1')

```

```{r scatterPlots}

plotComparativeScat(IndicatorsDF, 'DensMoradBanheiro',
                    'IDEB', 
                    'Resident/bathroom density',
                    IndicatorsDF, 'MaterialParedes',
                    'IDEB',
                    'Household wall material',
                    IndicatorsDF, 'Pavimentacao',
                    'IDEB', 
                    'Paving',
                    IndicatorsDF, 'MeiofioGuia',
                    'IDEB', 
                    'Curb / Guide',
                    IndicatorsDF, 'ColetaLixo',
                    'IDEB', 
                    'Waste collection',
                    IndicatorsDF,
                    'AtendimentoEnergia',
                    'IDEB', 
                    'Electricity supply',
                    'Figure3')

```

```{r gwOptimum}

gwOptimum <- function(datafile, varname1, varname2, b.min, b.max, step) {
  
  data <-
    merge(centroidsDF,
          datafile,
          by = "CodMunicipio")
  data <- na.exclude(data)
  
  coords <- data.frame(X = data$long,
                       Y = data$lat)
  data <- data[, c(varname1, varname2)]
  
  formula <- paste(varname2, "~", varname1)
  
  thisbw <- gwr.bw(
    formula = formula,
    dframe = data,
    coords = coords,
    kernel = 'fixed',
    b.min = b.min,
    b.max = b.max,
    step = step
  )
  
  thisbw['bw']
  
}
```

```{r DataLPCC}

library(reshape)

lcorrel <- function(DFrame, bw, Coords) {
  
  Dij <- as.matrix(dist(Coords))
  
  Obs <- nrow(DFrame)
  VarNo <- ncol(DFrame)
  VarSQ <- VarNo ^ 2
  
  Ne <- round(Obs * bw, 0)
  DFS <- Ne - 2
  
  MeltMeNames <- melt(cor(DFrame))
  TNames <- t(paste(MeltMeNames$X1, 
                    MeltMeNames$X2, 
                    sep = "_"))
  
  cor_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  tv_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  sign_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  BF_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  
  wtcor_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  gwsign_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  BF_gw_table_out <-
    as.data.frame(setNames(
      replicate(VarSQ, numeric(0), simplify = F),
      TNames[1:VarSQ]))
  
  DNames <- names(DFrame)
  
  for (m in 1:Obs) {
    
    #Get the data
    DataSet <- data.frame(DFrame, 
                          DNeighbour = Dij[, m])
    
    #Sort by distance
    DataSetSorted <-
      DataSet[order(DataSet$DNeighbour), ]
    
    #Keep Nearest Neighvbours
    SubSet1 <- DataSetSorted[1:Ne, ]
    
    Kernel_H <- max(SubSet1$DNeighbour)
    Wts <- (1 - (SubSet1$DNeighbour / Kernel_H)^2)^2
    
    #Remove Distance to NN columne
    SubSet <- SubSet1[, 1:VarNo]
    
    #Calculate Correlation Matrix
    CorMatrix <- cor(SubSet, method = "pearson")
    
    t_matrix <-
      matrix(
        data = NA,
        nrow = VarNo,
        ncol = VarNo,
        dimnames = list(DNames, DNames)
      )
    sig_matrix <-
      matrix(
        data = NA,
        nrow = VarNo,
        ncol = VarNo,
        dimnames = list(DNames, DNames)
      )
    
    for (i in 1:VarNo) {
      for (j in 1:VarNo) {
        if (j != i) {
          t_matrix[i, j] <-
            (CorMatrix[i, j] * sqrt(DFS)) / 
            (sqrt(1 - (CorMatrix[i, j] ^ 2)))
          sig_matrix[i, j] <- 
            2 * (1 - pt(abs(t_matrix[i, j]), 
                        df = DFS))
        }
      }
    }
    
    #Store in table
    MeltMeV <- melt(CorMatrix)
    cor_table_out[m, ] <- t(MeltMeV$value)
    
    MeltMeTv <- melt(t_matrix)
    tv_table_out[m, ] <- t(MeltMeTv$value)
    
    MeltMeSign <- melt(sig_matrix)
    sign_table_out[m, ] <- t(MeltMeSign$value)
    
    BF_table_out[m, ] <-
      p.adjust(sign_table_out[m, ], 
               method = "bonferroni", 
               n = Obs)
    
  }
  
  lcor.results <-
    list(
      LPCC = cor_table_out,
      LPCC_t = tv_table_out,
      LPCC_sig = sign_table_out,
      LPCC_sig_BF = BF_table_out
    )
  
  return(lcor.results)
  
}

mc.lcorrel <- function(Nsim = 99, bwSIM, CorVars, Coord.X, Coord.Y) {

  lcorSIM <- matrix(data = NA,
                    nrow = Nsim,
                    ncol = 6)
  
  Obs <- nrow(CorVars)
  
  Coords <- cbind(Coord.X, Coord.Y)
  
  lcc0 <- lcorrel(CorVars, bwSIM, Coords)
  Obs.var.lpcc <- var(lcc0$LPCC[, 2])

  for (i in 1:Nsim) {
    lccSIM <- lcorrel(CorVars, 
                      bwSIM, 
                      Coords[sample(nrow(Coords)), ])
    
    lcorSIM[i, 1] <- i
    lcorSIM[i, 2] <- mean(lccSIM$LPCC[, 2])
    lcorSIM[i, 3] <- min(lccSIM$LPCC[, 2])
    lcorSIM[i, 4] <- max(lccSIM$LPCC[, 2])
    lcorSIM[i, 5] <- var(lccSIM$LPCC[, 2])
    
    if (lcorSIM[i, 5] >= Obs.var.lpcc) {
      lcorSIM[i, 6] <- 1
    }
    else
    {
      lcorSIM[i, 6] <- 0
    }
    
  }
  
  C.test.lp <- sum(lcorSIM[, 6])

  if ((Nsim - C.test.lp) < C.test.lp) {
    C.test.lp = Nsim - C.test.lp
  }

  pseudo.p.lpcc = (1 + C.test.lp) / (Nsim + 1)

  SIMs <-
    data.frame(
      SIM.ID = lcorSIM[, 1],
      SIM.meanLPCC = lcorSIM[, 2],
      SIM.minLPCC = lcorSIM[, 3],
      SIM.maxLPCC = lcorSIM[, 4],
      SIM.varLPCC = lcorSIM[, 5],
      SIM.extrLPCC = lcorSIM[, 6]
    )
  
  return(list(
    SIM = SIMs,
    LC.Obs = lcc0,
    pseudo.p.lpcc = pseudo.p.lpcc
  ))
  
}

DataLPCC <- function(datafile, varname1, varname2) {
  
  data <- subset(datafile, 
                 select =
                   c("CodMunicipio",
                     varname1,
                     varname2)
                 )
  
  data <-
    merge(centroidsDF,
          data,
          by = "CodMunicipio")
  data <- na.exclude(data)
  
  n <- nrow(data)
  
  Bandwidth <- 1/3
  
  thisMC <-
    mc.lcorrel(
      Nsim = 19,
      bwSIM = Bandwidth,
      CorVars = data.frame(X1 = data[, varname1],
                           X2 = data[, varname2]),
      Coord.X = data$long,
      Coord.Y = data$lat
    )

  LPCC <-
    data.frame(
      LPCC = thisMC$LC.Obs['LPCC']$LPCC$X1_X2,
      LPCC_t = thisMC$LC.Obs['LPCC_t']$LPCC_t$X1_X2,
      LPCC_sig_BF = thisMC$LC.Obs['LPCC_sig_BF']$LPCC_sig_BF$X1_X2
    )
  
  n <- n
  
  p <- thisMC$pseudo.p.lpcc
  
  share <-
    scales::percent(length(LPCC$LPCC_sig_BF[LPCC$LPCC_sig_BF <= 0.05]) /
    length(LPCC$LPCC_sig_BF), accuracy = 0.1) 
  
  range <- range(LPCC$LPCC[LPCC$LPCC_sig_BF <= 0.05])
  range <- formatC(range, format = "f", 2)
  range <- paste0(range[1], "-", range[2])
  
  RPushbullet::pbPost(
    type = "note",
    title = paste(varname1, 
                  "x", 
                  varname2, 
                  "finished!"),
    body = paste(
      "bw =",
      formatC(Bandwidth, format = "E", 1),
      "n= ",
      n,
      "; share = ",
      share,
      "; range = ",
      range
    ),
    apikey = "o.SYjKv7goGyRzOWif4k8hwA6wPw1Hg00q",
    devices = "Galaxy A8"
  )
  
  return(list(bw = formatC(Bandwidth, 
                           format = "E", 
                           1),
              CodMunicipio = data$CodMunicipio,
              LPCC = LPCC,
              n = n,
              p = p,
              share = share,
              range = range))
  
}

```

```{r Table6}

D1IDEBLPCC <- DataLPCC(DimensionsDF, 'D1', 'IDEB')
D2IDEBLPCC <- DataLPCC(DimensionsDF, 'D2', 'IDEB')
D3IDEBLPCC <- DataLPCC(DimensionsDF, 'D3', 'IDEB')
D4IDEBLPCC <- DataLPCC(DimensionsDF, 'D4', 'IDEB')
D5IDEBLPCC <- DataLPCC(DimensionsDF, 'D5', 'IDEB')
SEIDEBLPCC <- DataLPCC(DimensionsDF, 'SE', 'IDEB')

Table6 <-
  data.frame(
    Indic = c(
      "IDEBxD1",
      "IDEBxD2",
      "IDEBxD3",
      "IDEBxD4",
      "IDEBxD5",
      "IDEBxSE"
    ),
    n = integer(6),
    share = character(6),
    range = character(6),
    stringsAsFactors = FALSE
  )
Table6$n <- 
  c(
    unname(unlist(D1IDEBLPCC['n'])),
    unname(unlist(D2IDEBLPCC['n'])),
    unname(unlist(D3IDEBLPCC['n'])),
    unname(unlist(D4IDEBLPCC['n'])),
    unname(unlist(D5IDEBLPCC['n'])),
    unname(unlist(SEIDEBLPCC['n']))
  )
Table6$share <-
  c(
    unname(unlist(D1IDEBLPCC['share'])),
    unname(unlist(D2IDEBLPCC['share'])),
    unname(unlist(D3IDEBLPCC['share'])),
    unname(unlist(D4IDEBLPCC['share'])),
    unname(unlist(D5IDEBLPCC['share'])),
    unname(unlist(SEIDEBLPCC['share']))
  )
Table6$range <-
  c(
    unname(unlist(D1IDEBLPCC['range'])),
    unname(unlist(D2IDEBLPCC['range'])),
    unname(unlist(D3IDEBLPCC['range'])),
    unname(unlist(D4IDEBLPCC['range'])),
    unname(unlist(D5IDEBLPCC['range'])),
    unname(unlist(SEIDEBLPCC['range']))
  )

xlsx::write.xlsx(
    Table6,
    file = "data/Table6.xls",
    row.names = FALSE,
    col.names = TRUE
)

save.image("~/My Work/Meus trabalhos/artigo School Inequalities and Urban Welfare/.RData")

```

```{r Table8}

Table8 <-
  data.frame(
    Indic = character(),
    n = integer(),
    share = character(),
    range = character(),
    stringsAsFactors = FALSE
  )

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'EsgCeuAberto')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxEsg",
    n = results$n,
    share = results$share,
    range = results$range,
    stringsAsFactors = FALSE
          )
  )
EsgIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'DensMoradBanheiro')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxBanh",
    n = results$n,
    share = results$share,
    range = results$range,
    stringsAsFactors = FALSE
    )
  )
BanhIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'DensDomiciliar')
Table8 <-
  rbind(
    Table8,
    data.frame(
      Indic = "IDEBxDorm",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
DormIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'Pavimentacao')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxPav",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
PavIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'MeiofioGuia')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxMeio",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
MeioIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB', 'TDeslocamento')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxTDes",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
TDesIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','IdentLogradouro')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxIdLogr",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
IdLogrIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','BueiroBocadelobo')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxBueiro",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
BueiroIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','MaterialParedes')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxMarPar",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
MarParIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','LixoAcumulado')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxLixoAcum",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
LixoAcumIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','AtendimentoEnergia')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxAtendEne",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
AtendEneIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','AtendimentoEsgoto')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxAtendEsg",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
AtendEsgIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','AtendimentoAgua')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxAtendAgua",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
AtendAguaIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','Calcada')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxCalcada",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
CalcadaIDEBLPCC <- results


results <-  DataLPCC(IndicatorsDF, 'IDEB','Arborizacao')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxArboriz",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
ArborizIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','AglomSubnormal')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxAgSubn",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
AgSubnIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','IluminacaoPublica')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxIlumPub",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
IlumPublIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','EspecDomicilio')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxEspecDom",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
EspecDomIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','ENEM')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxENEM",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
ENEMIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','ColetaLixo')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxColLixo",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
ColLixoIDEBLPCC <- results

results <-  DataLPCC(IndicatorsDF, 'IDEB','RampaCadeirantes')
Table8 <-
  rbind(Table8,
          data.frame(
    Indic = "IDEBxRampCad",
      n = results$n,
      share = results$share,
      range = results$range,
      stringsAsFactors = FALSE
    )
  )
RampCadIDEBLPCC <- results

xlsx::write.xlsx(
    Table8,
    file = "data/Table8.xls",
    row.names = FALSE,
    col.names = TRUE
)

save.image("~/My Work/Meus trabalhos/artigo School Inequalities and Urban Welfare/.RData")

```

```{r histPlot}
library(ggpubr)

histPlot <- function(plotData, plotTitle) {
  
  data <-
    dplyr::filter(plotData,
                  LPCC_sig_BF <= 0.05)
  
  thisGraph <-
    ggplot(data,
           aes(LPCC))
  
  thisGraph <- thisGraph +
    geom_histogram(aes(y = stat(width * density)),
                   bins = 30,
                   fill = "dodgerblue",
                   color="black")
  
  thisGraph <- thisGraph + 
    theme(
      panel.background = element_rect(fill = "white",
                                      colour = "white"),
      panel.border = element_blank(),
      panel.grid.major = element_line(colour = "grey80"),
      panel.grid.minor = element_blank(),
      axis.text = element_text(size = 9),
      axis.title = element_text(size = 11, face = "bold")
    )
  
  thisGraph <- thisGraph +
    scale_x_continuous(labels =                         scales::number_format(accuracy = 0.1))
  thisGraph <- thisGraph +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1))
  
  thisGraph <- thisGraph +
    labs(x = expression(R ~ " (" ~ p <= 0.5 ~ ")"),
         y = "rel. freq.")
  
  thisGraph <- thisGraph +
    ggtitle(plotTitle)
  
  thisGraph
  
}

plotComparativeHist <-
  function(plotDataTL,
           plotTitleTL,
           plotDataTR,
           plotTitleTR,
           plotDataML,
           plotTitleML,
           plotDataMR,
           plotTitleMR,
           plotDataBL,
           plotTitleBL,
           plotDataBR,
           plotTitleBR,
           figfilename) {
    
  # Make histogram plots
  pTL <- histPlot(plotDataTL, plotTitleTL)
  pTR <- histPlot(plotDataTR, plotTitleTR)
  pML <- histPlot(plotDataML, plotTitleML)
  pMR <- histPlot(plotDataMR, plotTitleMR)
  pBL <- histPlot(plotDataBL, plotTitleBL)
  pBR <- histPlot(plotDataBR, plotTitleBR)
  
  thisGraph <- ggpubr::ggarrange(pTL, pTR, pML, pMR, pBL, pBR,
                       ncol = 2, nrow = 3
  )
  
  # Connects to 'png' device for saving plot as .png a file
  Cairo::CairoPNG(
    filename = paste0("images/", figfilename, ".", "png"),
    width = 3600,
    height = 3600,
    dpi = 600,
    bg = "white"
  )
  
  # Draws the final plot to device
  plot(thisGraph)
  
  # Closes connection to 'png' device
  dev.off()

}

```

```{r plotComparativeHist}

plotComparativeHist(D1IDEBLPCC$LPCC, "IDEB vs. D1",
                    D2IDEBLPCC$LPCC, "IDEB vs. D2",
                    D3IDEBLPCC$LPCC, "IDEB vs. D3",
                    D4IDEBLPCC$LPCC, "IDEB vs. D4",
                    D5IDEBLPCC$LPCC, "IDEB vs. D5",
                    SEIDEBLPCC$LPCC, "IDEB vs. SE",
                    "Figure2")

```

```{r Table7}

Table7 <- data.frame(
  var = c(
    "IDEB x D1",
    "IDEB x D2",
    "IDEB x D3",
    "IDEB x D4",
    "IDEB x D5",
    "IDEB x SE"
  ),
  avg = c(
    mean(D1IDEBLPCC$LPCC$LPCC[D1IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    mean(D2IDEBLPCC$LPCC$LPCC[D2IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    mean(D3IDEBLPCC$LPCC$LPCC[D3IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    mean(D4IDEBLPCC$LPCC$LPCC[D4IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    mean(D5IDEBLPCC$LPCC$LPCC[D5IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    mean(SEIDEBLPCC$LPCC$LPCC[SEIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5])
  ),
  stdev = c(
    stats::sd(D1IDEBLPCC$LPCC$LPCC[D1IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    stats::sd(D2IDEBLPCC$LPCC$LPCC[D2IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    stats::sd(D3IDEBLPCC$LPCC$LPCC[D3IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    stats::sd(D4IDEBLPCC$LPCC$LPCC[D4IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    stats::sd(D5IDEBLPCC$LPCC$LPCC[D5IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    stats::sd(SEIDEBLPCC$LPCC$LPCC[SEIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5])
  ),
  kurt = c(
    moments::kurtosis(D1IDEBLPCC$LPCC$LPCC[D1IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3,
    moments::kurtosis(D2IDEBLPCC$LPCC$LPCC[D2IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3,
    moments::kurtosis(D3IDEBLPCC$LPCC$LPCC[D3IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3,
    moments::kurtosis(D4IDEBLPCC$LPCC$LPCC[D4IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3,
    moments::kurtosis(D5IDEBLPCC$LPCC$LPCC[D5IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3,
    moments::kurtosis(SEIDEBLPCC$LPCC$LPCC[SEIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]) - 3
  ),
  skew = c(
    moments::skewness(D1IDEBLPCC$LPCC$LPCC[D1IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    moments::skewness(D2IDEBLPCC$LPCC$LPCC[D2IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    moments::skewness(D3IDEBLPCC$LPCC$LPCC[D3IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    moments::skewness(D4IDEBLPCC$LPCC$LPCC[D4IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    moments::skewness(D5IDEBLPCC$LPCC$LPCC[D5IDEBLPCC$LPCC$LPCC_sig_BF <= 0.5]),
    moments::skewness(SEIDEBLPCC$LPCC$LPCC[SEIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5])
  )
)

xlsx::write.xlsx(
  data.frame(
    var = Table7$var,
    avg = formatC(Table7$avg, format = "f", 2),
    stdev = formatC(Table7$stdev, format = "f", 2),
    kurt = formatC(Table7$kurt, format = "f", 2)
    ,
    skew = formatC(Table7$skew, format = "f", 2)
  ),
  file = "data/Table7.xls",
  row.names = FALSE,
  col.names = TRUE
)

```

```{r Table9}

Table9 <- data.frame(
  var = character(),
  avg = numeric(),
  stdev = numeric(),
  kurt =  numeric(),
  skew =  numeric(),
  stringsAsFactors = FALSE
)

assym <- function(datafile, title) {
  
  thisResults <-
    data.frame(
      var = title,
      avg = mean(datafile),
      stdev = stats::sd(datafile),
      kurt =  moments::kurtosis(datafile),
      skew =  moments::skewness(datafile),
      stringsAsFactors = FALSE
    )
  
  thisResults
  
}

results <-
  assym(EsgIDEBLPCC$LPCC$LPCC[EsgIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Open sewage")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(BanhIDEBLPCC$LPCC$LPCC[BanhIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Resident/bathroom density")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(DormIDEBLPCC$LPCC$LPCC[DormIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Resident/dormitory density")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(PavIDEBLPCC$LPCC$LPCC[PavIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Paving")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(MeioIDEBLPCC$LPCC$LPCC[MeioIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Curb / Guide")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(TDesIDEBLPCC$LPCC$LPCC[TDesIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Adeq. Home-to-Work Displacement")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(IdLogrIDEBLPCC$LPCC$LPCC[IdLogrIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? IdentLogradouro")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(BueiroIDEBLPCC$LPCC$LPCC[BueiroIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? BueiroBocadelobo")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(MarParIDEBLPCC$LPCC$LPCC[MarParIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? MaterialParedes")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(LixoAcumIDEBLPCC$LPCC$LPCC[LixoAcumIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? LixoAcumulado")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(AtendEneIDEBLPCC$LPCC$LPCC[AtendEneIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? AtendimentoEnergia")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(AtendEsgIDEBLPCC$LPCC$LPCC[AtendEsgIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? AtendimentoEsgoto")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(AtendAguaIDEBLPCC$LPCC$LPCC[AtendAguaIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? AtendimentoAgua")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(AtendAguaIDEBLPCC$LPCC$LPCC[AtendAguaIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? AtendimentoAgua")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(CalcadaIDEBLPCC$LPCC$LPCC[CalcadaIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Calcada")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(ArborizIDEBLPCC$LPCC$LPCC[ArborizIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? Arborizacao")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(AgSubnIDEBLPCC$LPCC$LPCC[AgSubnIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? AglomSubnormal")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(IlumPublIDEBLPCC$LPCC$LPCC[IlumPublIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? IluminacaoPublica")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(EspecDomIDEBLPCC$LPCC$LPCC[EspecDomIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? EspecDomicilio")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(ENEMIDEBLPCC$LPCC$LPCC[ENEMIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? ENEM")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(ColLixoIDEBLPCC$LPCC$LPCC[ColLixoIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? ColetaLixo")

Table9 <-
  rbind(Table9,
        results)

results <-
  assym(RampCadIDEBLPCC$LPCC$LPCC[RampCadIDEBLPCC$LPCC$LPCC_sig_BF <= 0.5], "IDEB ? RampaCadeirantes")

Table9 <-
  rbind(Table9,
        results)

Table9 <- Table9[order(Table9$avg, decreasing = TRUE),]

xlsx::write.xlsx(
  data.frame(
    var = Table9$var,
    avg = formatC(Table9$avg, format = "f", 2),
    stdev = formatC(Table9$stdev, format = "f", 2),
    kurt = formatC(Table9$kurt, format = "f", 2)
    ,
    skew = formatC(Table9$skew, format = "f", 2),
    stringsAsFactors = FALSE
  ),
  file = "data/Table9.xls",
  row.names = FALSE,
  col.names = TRUE
)

```


```{r}

library(ggplot2)
library(grid)

plotMapFigure <- function(map, datafile, varname, limits, figfilename) {
  
  data <- merge(datafile,
                subset(IDlist, select = -nome),
                by = 'CodMunicipio',
                all.y = FALSE)
  
  finalMap <- merge(map, data, by = "id", all.x = TRUE)
  finalMap <- finalMap[order(finalMap$order),]
  
  Cairo::CairoPNG(
    filename = paste0("images/", figfilename, ".", "png"),
    width = 3600,
    height = 3600,
    dpi = 600,
    bg = "white"
  )
  
  thisMap <- ggplot()
  
  thisMap <- thisMap + geom_polygon(
    data = finalMap,
    aes_string(
      x = "long",
      y = "lat",
      group = "group",
      fill = varname
    ),
    colour = "grey80",
    size = 0.1
  )
  
  thisMap <- thisMap + theme_bw() +
    xlab("Longitude") +
    ylab("Latitude") +
    theme(
      panel.border = element_blank(),
      panel.grid.major = element_line(colour = "grey80"),
      panel.grid.minor = element_blank()
    )

  thisMap <-
    thisMap + scale_fill_gradientn(
      colours = rev(colorRamps::matlab.like2(3)),
      values = scales::rescale(rev(limits), to = c(0, 1)),
      limits = limits,
      na.value = "white"
    )

  ggsn::north2(thisMap,
               scale = 0.15,
               x = 0.8,
               symbol = 3)
  
  plot(thisMap)
  
  dev.off()
  
}

```


## References
```{r}
citations()
```
- Harvey, D. (1971). *Social Justice and the City*. London: Edward Arnold. 
- Ribeiro, L. C. de Q., Koslinski, M. C., Zuccarelli, C., & Christov?o, A. C. (2016). Desafios Urbanos ? Democratiza??o do Acesso ?s Oportunidades Educacionais nas Metr?poles Brasileiras. *Educa??o & Sociedade*, *37*(134), 171-193. https://doi.org/10.1590/ES0101-73302016157093
- Ribeiro, L. C. de Q., & Ribeiro, M. G. (2013). *IBEU - Indice de Bem-Estar Urbano*. Rio de Janeiro: Letra Capital. Retrieved from http://www.observatoriodasmetropoles.net/images/abook_file/ibeu_livro.pdf


